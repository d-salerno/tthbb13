From 8cb31b5587b7e73780d58976a8d174c01330cf44 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Wed, 17 Sep 2014 16:20:58 +0200
Subject: [PATCH 01/22] Changed HTTWrapper to work with newer tagger version

Added new devel version of HTT. Corresponds to aca15e

Added first version of HTTJetTagInfo to DataFormats

Added HTTTopJetProperties to classes_4.h

Removed accidentally created HTTJetTagInfo.h

Add a few more HTT versions of producers/helpers

Add HTTTopJetProducer (copy of CATopJetProducer)

More HTT interfacing

seems to work now..

Started cleaning up a bit

a bit more tidy up

Started filling all the properties, removed useless Helper

full chain for pruned mass

Added top mass

Added unfiltered mass

Added fW (not yet implemented in HTT itself)

Added mass_ratio_passed

Added more config options to HTT, removed HTT from CATopJetTagger

Moved HTTProducer from untracked to tracked config parameters

Cleaned up comments in Wrapper a bit

Updated HTT to 4779fe4601060cfb5825836bfafea0e37c507983

Small changes to wrapper

HTT now has working sj pT cut. a92f9f67973387cc4b2497b101873d793e67a79a

Updated mode handling: e1f51f128be23b1aaa1d714df0d766fd1897191c

Added fW (849a93b565d310fd8403c24c683ef693e74ac8b8)
---
 DataFormats/JetReco/interface/HTTTopJetTagInfo.h   |  73 +++
 DataFormats/JetReco/src/classes_4.h                |  15 +-
 DataFormats/JetReco/src/classes_def_4.xml          |  17 +
 RecoJets/JetAlgorithms/interface/HEPTopTagger.h    | 527 ++++++---------------
 .../JetAlgorithms/interface/HEPTopTaggerWrapper.h  | 185 +++++---
 RecoJets/JetAlgorithms/src/HEPTopTagger.cc         | 350 ++++++++++++++
 RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc  |  71 +--
 RecoJets/JetProducers/plugins/CATopJetProducer.cc  |  12 +-
 RecoJets/JetProducers/plugins/CATopJetProducer.h   |   2 -
 .../JetProducers/plugins/FastjetJetProducer.cc     |   4 +
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc | 184 +++++++
 RecoJets/JetProducers/plugins/HTTTopJetProducer.h  | 131 +++++
 .../JetProducers/plugins/VirtualJetProducer.cc     |  13 +-
 RecoJets/JetProducers/plugins/VirtualJetProducer.h |  10 +-
 .../JetProducers/python/CATopJetParameters_cfi.py  |   2 +-
 15 files changed, 1091 insertions(+), 505 deletions(-)
 create mode 100644 DataFormats/JetReco/interface/HTTTopJetTagInfo.h
 create mode 100644 RecoJets/JetAlgorithms/src/HEPTopTagger.cc
 create mode 100644 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
 create mode 100644 RecoJets/JetProducers/plugins/HTTTopJetProducer.h

diff --git a/DataFormats/JetReco/interface/HTTTopJetTagInfo.h b/DataFormats/JetReco/interface/HTTTopJetTagInfo.h
new file mode 100644
index 0000000..98f133e
--- /dev/null
+++ b/DataFormats/JetReco/interface/HTTTopJetTagInfo.h
@@ -0,0 +1,73 @@
+#ifndef AnalysisDataFormats_TopObjects_interface_HTTTopJetTagInfo_h
+#define AnalysisDataFormats_TopObjects_interface_HTTTopJetTagInfo_h
+
+
+// \class HTTTopJetTagInfo
+// 
+// \short specific tag info for HEPTopTagger tagging algorithm
+// HTTTopJetTagInfo is a class to hold the discriminator variables for the
+// HEPTopTagger algorithm.
+// 
+//
+// \author Gregor Kasieczka (based on  CATopJetTagInfo by Salvatore Rappoccio)
+// \version first version on 25 Sep 2014
+
+#include "DataFormats/BTauReco/interface/RefMacros.h"
+#include "DataFormats/BTauReco/interface/JetTagInfo.h"
+#include "DataFormats/BTauReco/interface/TaggingVariable.h"
+#include <vector>
+
+namespace reco {
+ 
+class HTTTopJetProperties {
+public:
+  HTTTopJetProperties() {
+    topMass          = 0.;
+    unfilteredMass   = 0.;
+    prunedMass	     = 0.;
+    fW		     = 0.;
+    massRatioPassed  = 0.;
+    isMultiR	     = 0;
+    Rmin	     = 0.;
+    RminExpected     = 0.;
+  }
+  double              topMass;         //<! Mass of the HTT top quark candidate [GeV] (at R=Rmin for MultiR)
+  double              unfilteredMass;  //<! Unfiltered mass of the triplet [GeV] (at R=Rmin for MultiR)
+  double              prunedMass;      //<! Mass of the pruned fat jet [GeV] (at R=Rmin for MultiR)
+  double              fW;              //<! Minimum distance of m_ij/m_123 from m_W/m_top (at R=Rmin for MultiR)
+  double              massRatioPassed; //<! Did the candidate pass the default mass ratio? Can be used instead of fW (at R=Rmin for MultiR)
+  bool                isMultiR;        //<! Tagger operated in MultiR mode
+  double              Rmin;            //<! R_min found in MultiR procedure. Set to -1 for non-MultiR mode.
+  double              RminExpected;    //<! R_min expected for a top quark based on filtered fat-jet pT. Set to -1 for non-MultiR mode.
+};
+
+ class HTTTopJetTagInfo : public JetTagInfo {
+public:
+  typedef edm::RefToBase<Jet> jet_type;
+  typedef HTTTopJetProperties  properties_type;
+    
+    HTTTopJetTagInfo(void) {}
+
+    virtual ~HTTTopJetTagInfo(void) {}
+  
+    virtual HTTTopJetTagInfo* clone(void) const { return new HTTTopJetTagInfo(*this); }
+    
+    const properties_type & properties() const {
+      return properties_;
+    }
+
+    void insert(const edm::RefToBase<Jet> & jet, const HTTTopJetProperties & properties) {
+      setJetRef(jet);
+      properties_ = properties;
+    }
+
+protected:
+    properties_type properties_;
+
+};
+
+DECLARE_EDM_REFS( HTTTopJetTagInfo )
+
+}
+
+#endif // AnalysisDataFormats_TopObjects_interface_HTTTopJetTagInfo_h
diff --git a/DataFormats/JetReco/src/classes_4.h b/DataFormats/JetReco/src/classes_4.h
index 1de6d02..9567f13 100644
--- a/DataFormats/JetReco/src/classes_4.h
+++ b/DataFormats/JetReco/src/classes_4.h
@@ -37,6 +37,7 @@
 #include "DataFormats/Common/interface/Ptr.h"
 
 #include "DataFormats/JetReco/interface/CATopJetTagInfo.h"
+#include "DataFormats/JetReco/interface/HTTTopJetTagInfo.h"
 
 namespace DataFormats_JetReco {
   struct dictionary4 {
@@ -178,7 +179,6 @@ namespace DataFormats_JetReco {
     edm::Wrapper<edm::Association<reco::FFTCaloJetCollection> > w_a_gj_fft_2;
 
 
-
     reco::CATopJetProperties                                            catopjetp;
     std::pair<edm::RefToBase<reco::Jet>, reco::CATopJetProperties>      catopjetp_p;
 
@@ -191,6 +191,19 @@ namespace DataFormats_JetReco {
     edm::reftobase::Holder<reco::BaseTagInfo, reco::CATopJetTagInfoRef> rb_catopjet;
     edm::reftobase::RefHolder<reco::CATopJetTagInfoRef>                 rbh_catopjet; 
 
+
+    reco::HTTTopJetProperties                                            htttopjetp;
+    std::pair<edm::RefToBase<reco::Jet>, reco::HTTTopJetProperties>      htttopjetp_p;
+
+    reco::HTTTopJetTagInfo                                               htttopjet;
+    reco::HTTTopJetTagInfoCollection                                     htttopjet_c;
+    reco::HTTTopJetTagInfoRef                                            htttopjet_r;
+    reco::HTTTopJetTagInfoRefProd                                        htttopjet_rp;
+    reco::HTTTopJetTagInfoRefVector                                      htttopjet_rv;
+    edm::Wrapper<reco::HTTTopJetTagInfoCollection>                       htttopjet_wc;
+    edm::reftobase::Holder<reco::BaseTagInfo, reco::HTTTopJetTagInfoRef> rb_htttopjet;
+    edm::reftobase::RefHolder<reco::HTTTopJetTagInfoRef>                 rbh_htttopjet; 
+
   };
 }
 #endif
diff --git a/DataFormats/JetReco/src/classes_def_4.xml b/DataFormats/JetReco/src/classes_def_4.xml
index dc60276..ef0d750 100644
--- a/DataFormats/JetReco/src/classes_def_4.xml
+++ b/DataFormats/JetReco/src/classes_def_4.xml
@@ -155,4 +155,21 @@
   <class name="edm::reftobase::Holder<reco::BaseTagInfo, reco::CATopJetTagInfoRef>" />
   <class name="edm::reftobase::RefHolder<reco::CATopJetTagInfoRef>" />
 
+
+  <class name="reco::HTTTopJetProperties" ClassVersion="11">
+   <version ClassVersion="11" checksum="1763149559"/>
+  </class>
+  <class name="std::pair<edm::RefToBase<reco::Jet>, reco::HTTTopJetProperties>"/>
+ 
+  <class name="reco::HTTTopJetTagInfo" ClassVersion="10">
+   <version ClassVersion="10" checksum="1184606281"/>
+  </class>
+  <class name="reco::HTTTopJetTagInfoCollection"/>
+  <class name="reco::HTTTopJetTagInfoRef"/>
+  <class name="reco::HTTTopJetTagInfoRefProd"/>
+  <class name="reco::HTTTopJetTagInfoRefVector"/>
+  <class name="edm::Wrapper<reco::HTTTopJetTagInfoCollection>"/>
+  <class name="edm::reftobase::Holder<reco::BaseTagInfo, reco::HTTTopJetTagInfoRef>" />
+  <class name="edm::reftobase::RefHolder<reco::HTTTopJetTagInfoRef>" />
+
 </lcgdict>
diff --git a/RecoJets/JetAlgorithms/interface/HEPTopTagger.h b/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
index f84e14f..c66a79b 100644
--- a/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
+++ b/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
@@ -1,385 +1,142 @@
-#ifndef __HEPTOPTAGGER_HH__
-#define __HEPTOPTAGGER_HH__
-
-class HEPTopTagger {
-public:
-
-  typedef fastjet::ClusterSequence ClusterSequence;
-  typedef fastjet::JetAlgorithm JetAlgorithm;
-  typedef fastjet::JetDefinition JetDefinition;
-  typedef fastjet::PseudoJet PseudoJet;
-
-  HEPTopTagger(const fastjet::ClusterSequence & cs,
-	       const fastjet::PseudoJet & jet);
-
-  HEPTopTagger(const fastjet::ClusterSequence & cs,
-	       const fastjet::PseudoJet & jet,
-	       double mtmass, double mwmass);
-
-  void run_tagger();
-  bool is_maybe_top() const {return _is_maybe_top;}
-  bool is_masscut_passed() const {return _is_masscut_passed;}
-  const PseudoJet & top_candidate() const {return _top_candidate;}
-  const std::vector<PseudoJet> & top_subjets() const {return _top_subjets;}
-  const std::vector<PseudoJet> & top_hadrons() const {return _top_hadrons;}
-  unsigned top_count() const {return _top_count;}
-  const std::vector<PseudoJet> & hardparts() const {return _top_parts;}
-  unsigned parts_size() const {return _parts_size;}
-  double delta_top() const {return _delta_top;}
-  const std::vector<std::vector<PseudoJet> > & candjets() const {return _candjets;}
-  void get_setting() const;
-  void get_info() const;
-  // for setting parameters
-  void set_max_subjet_mass(double x) {_max_subjet_mass=x;}
-  void set_mass_drop_threshold(double x) {_mass_drop_threshold=x;}
-  void set_top_range(double xmin, double xmax) {_mtmin=xmin; _mtmax=xmax;}
-  void set_mass_ratio_range(double rmin, double rmax) {_rmin=rmin; _rmax=rmax;}
-  void set_mass_ratio_cut(double m23cut, double m13cutmin,double m13cutmax){_m23cut=m23cut; _m13cutmin=m13cutmin; _m13cutmax=m13cutmax;}
-  void set_nfilt(unsigned nfilt) {_nfilt=nfilt;}
-  void set_filtering_jetalgorithm(JetAlgorithm jet_algorithm) {_jet_algorithm=jet_algorithm;}
-  void set_reclustering_jetalgorithm(JetAlgorithm jet_algorithm) {_jet_algorithm_recluster=jet_algorithm;}
-  // 
-  double cos_theta_h() const;
-  double dr_bjj() const;
-  std::vector<double> dr_values() const;
-
-private:
-  const ClusterSequence * _cs;
-  const PseudoJet _jet;
-  const double _mtmass, _mwmass;
-  double _mass_drop_threshold;
-  double _max_subjet_mass; // stop when subjet mass < 30 GeV
-  double _mtmin, _mtmax;
-  double _rmin, _rmax;
-  double _m23cut, _m13cutmin, _m13cutmax;
-  size_t _nfilt;
-  // filtering algorithm
-  JetAlgorithm _jet_algorithm;
-  JetAlgorithm _jet_algorithm_recluster;
-  
-  bool _is_masscut_passed;
-  bool _is_maybe_top;
-  double _delta_top;
-  unsigned _top_count;
-  unsigned _parts_size;
-  PseudoJet _top_candidate;
-  std::vector<PseudoJet> _top_subjets;
-  std::vector<PseudoJet> _top_hadrons;
-  std::vector<PseudoJet> _top_parts;
-  std::vector<std::vector<PseudoJet> > _candjets;
-
-  void FindHardSubst(const PseudoJet& jet, std::vector<fastjet::PseudoJet>& t_parts);
-  std::vector<PseudoJet> Filtering(const std::vector <PseudoJet> & top_constits, const JetDefinition & filtering_def);
-  void store_topsubjets(const std::vector<PseudoJet>& top_subs);
-  bool check_mass_criteria(const std::vector<fastjet::PseudoJet> & top_subs) const;
-  double check_cos_theta(const PseudoJet & jet, const PseudoJet & subj1,const PseudoJet & subj2) const;
-  PseudoJet Sum(const std::vector<PseudoJet>& );
-  double r_max_3jets(const fastjet::PseudoJet & jet1,const fastjet::PseudoJet & jet2,
-		     const fastjet::PseudoJet & jet3) const;
-
-  bool debugg;
-
-};
-//--------------------------------------------------------------------
-double HEPTopTagger::cos_theta_h() const {
-  return check_cos_theta(_top_candidate,_top_subjets[1],_top_subjets[2]);// m23 is closest to mW
-}
-
-double HEPTopTagger::dr_bjj() const{
-  if(_top_subjets.size()!=3){return -1;}
-  return r_max_3jets(_top_subjets[0],_top_subjets[1],_top_subjets[2]);
-}
-
-std::vector<double> HEPTopTagger::dr_values() const{
-  std::vector<double> dr_values;
-  dr_values.push_back(sqrt(_top_subjets[1].squared_distance(_top_subjets[2])));
-  dr_values.push_back(sqrt(_top_subjets[0].squared_distance(_top_subjets[2])));
-  dr_values.push_back(sqrt(_top_subjets[0].squared_distance(_top_subjets[1])));
-  return dr_values;
-}
-
-
-double HEPTopTagger::r_max_3jets(const fastjet::PseudoJet & jet1,const fastjet::PseudoJet & jet2,const fastjet::PseudoJet & jet3) const{
-  fastjet::PseudoJet jet12,jet13,jet23;
-  jet12=jet1+jet2;
-  jet13=jet1+jet3;
-  jet23=jet2+jet3;
-
-  double a=sqrt(jet1.squared_distance(jet2));
-  double b=sqrt(jet2.squared_distance(jet3));
-  double c=sqrt(jet3.squared_distance(jet1));
-  double dR1=a,dR2=a;
-
-  if(a<=b && a<=c){
-    dR1=a;
-    dR2=sqrt(jet12.squared_distance(jet3));
-  };
-  if(b<a && b<=c){
-    dR1=b;
-    dR2=sqrt(jet23.squared_distance(jet1));
-  };
-  if(c<a && c<b){
-    dR1=c;
-    dR2=sqrt(jet13.squared_distance(jet2));
-  };
-  return max(dR1,dR2);
-}
-
-double HEPTopTagger::check_cos_theta(const PseudoJet & jet,const PseudoJet & subj1,const PseudoJet & subj2) const
-{
-  // the two jets of interest: top and lower-pt prong of W
-  PseudoJet W2;
-  PseudoJet top = jet;
-  
-  if(subj1.perp2() < subj2.perp2())
-    {
-      W2 = subj1;
-    }
-  else
-    {
-      W2 = subj2;
-    }
-
-  // transform these jets into jets in the rest frame of the W
-  W2.unboost(subj1+subj2);
-  top.unboost(subj1+subj2);
-  
-  double csthet = (W2.px()*top.px() + W2.py()*top.py() + W2.pz()*top.pz())/sqrt(W2.modp2() * top.modp2());  
-  return(csthet);
-}
-
-void HEPTopTagger::FindHardSubst(const PseudoJet & this_jet, std::vector<fastjet::PseudoJet> & t_parts)
-{
-  PseudoJet parent1(0,0,0,0), parent2(0,0,0,0);
-  if (this_jet.m() < _max_subjet_mass || !_cs->has_parents(this_jet, parent1, parent2))
-    {
-      t_parts.push_back(this_jet);
-    }
-  else 
-    {
-      if (parent1.m() < parent2.m()) swap(parent1, parent2);
-      
-      FindHardSubst(parent1,t_parts);
-      
-      if (parent1.m() < _mass_drop_threshold * this_jet.m())
-	{
-	  FindHardSubst(parent2,t_parts);
-	}
-    }
-}
-
-void HEPTopTagger::store_topsubjets(const std::vector<PseudoJet>& top_subs){
-  _top_subjets.resize(0);
-  double m12=(top_subs[0]+top_subs[1]).m();
-  double m13=(top_subs[0]+top_subs[2]).m();
-  double m23=(top_subs[1]+top_subs[2]).m();
-  //double m123=(top_subs[0]+top_subs[1]+top_subs[2]).m();
-  double dm12=abs(m12-_mwmass);
-  double dm13=abs(m13-_mwmass);
-  double dm23=abs(m23-_mwmass);
-  //double dm_min=min(dm12,min(dm13,dm23));
-  if(dm23<=dm12 && dm23<=dm13){
-    _top_subjets.push_back(top_subs[0]); //supposed to be b
-    _top_subjets.push_back(top_subs[1]); //W-jet 1
-    _top_subjets.push_back(top_subs[2]); //W-jet 2		
-  }
-  else if(dm13<=dm12 && dm13<dm23){
-    _top_subjets.push_back(top_subs[1]); //supposed to be b
-    _top_subjets.push_back(top_subs[0]); //W-jet 1
-    _top_subjets.push_back(top_subs[2]); //W-jet 2
-  }
-  else if(dm12<dm23 && dm12<dm13){
-    _top_subjets.push_back(top_subs[2]); //supposed to be b
-    _top_subjets.push_back(top_subs[0]); //W-jet 1
-    _top_subjets.push_back(top_subs[1]); //W-jet 2
-  }
-  return;
-}
-
-bool HEPTopTagger::check_mass_criteria(const std::vector<PseudoJet> & top_subs) const{
-  bool is_passed=false;
-  double m12=(top_subs[0]+top_subs[1]).m();
-  double m13=(top_subs[0]+top_subs[2]).m();
-  double m23=(top_subs[1]+top_subs[2]).m();
-  double m123=(top_subs[0]+top_subs[1]+top_subs[2]).m();
-  if(
-     (atan(m13/m12)>_m13cutmin && _m13cutmax > atan(m13/m12)
-      && (m23/m123>_rmin && _rmax>m23/m123))
-     ||
-     (((m23/m123)*(m23/m123) < 1-_rmin*_rmin*(1+(m13/m12)*(m13/m12))) &&
-      ((m23/m123)*(m23/m123) > 1-_rmax*_rmax*(1+(m13/m12)*(m13/m12))) && 
-      (m23/m123 > _m23cut))
-     ||
-     (((m23/m123)*(m23/m123) < 1-_rmin*_rmin*(1+(m12/m13)*(m12/m13))) &&
-      ((m23/m123)*(m23/m123) > 1-_rmax*_rmax*(1+(m12/m13)*(m12/m13))) && 
-      (m23/m123 > _m23cut))
-     ){ 
-    is_passed=true;
-  }
-  return is_passed;
-}
-
-////////// Top-TAGGER: /////////////////////////////////////////////////////////////////
-HEPTopTagger::HEPTopTagger(const fastjet::ClusterSequence & cs,
-			   const fastjet::PseudoJet & jet) : 
-  _cs(&cs), _jet(jet), _mtmass(172.3), _mwmass(80.4), 
-  _mass_drop_threshold(0.8), _max_subjet_mass(30.),
-  _mtmin(172.3 - 25.),_mtmax(172.3 + 25.), _rmin(0.85*80.4/172.3),_rmax(1.15*80.4/172.3),
-  _m23cut(0.35),_m13cutmin(0.2),_m13cutmax(1.3),
-  _nfilt(5),_jet_algorithm(fastjet::cambridge_algorithm),_jet_algorithm_recluster(fastjet::cambridge_algorithm),
-  debugg(false)
-{}
-
-HEPTopTagger::HEPTopTagger(const fastjet::ClusterSequence & cs,
-			   const fastjet::PseudoJet & jet,
-			   double mtmass,double mwmass
-			   ) : 
-  _cs(&cs), _jet(jet), _mtmass(mtmass), _mwmass(mwmass), 
-  _mass_drop_threshold(0.8), _max_subjet_mass(30.),
-  _mtmin(mtmass - 25.),_mtmax(mtmass + 25.), _rmin(0.85*mwmass/mtmass),_rmax(1.15*mwmass/mtmass),
-  _m23cut(0.35),_m13cutmin(0.2),_m13cutmax(1.3),
-  _nfilt(5),_jet_algorithm(fastjet::cambridge_algorithm),_jet_algorithm_recluster(fastjet::cambridge_algorithm),
-  debugg(false)
-{}
-
-
-void HEPTopTagger::run_tagger()
-{
-  _delta_top=1000000000000.0;
-  _top_candidate.reset(0.,0.,0.,0.);
-  _top_count=0;
-  _parts_size=0;
-  _is_maybe_top=_is_masscut_passed=false;
-  _top_subjets.clear();
-  _top_hadrons.clear();
-  _top_parts.clear();
-
-  if(debugg)
-    {
-      cout << "mtmass in top_tagger: " << _mtmass << endl;
-      cout << "mwmass in top_tagger: " << _mwmass << endl;
-      cout << "jet input HEPTopTagger: " << endl;
-      //printjet(_jet);
-    }
-  
-  
-  // input this_jet, output _top_parts
-  FindHardSubst(_jet, _top_parts);
-  
-  // store hard substructure of the top candidate
-  _parts_size=_top_parts.size();
-  
-  // these events are not interesting 
-  if(_top_parts.size() < 3){return;}
-  
-  for(unsigned rr=0; rr<_top_parts.size(); rr++){
-    for(unsigned ll=rr+1; ll<_top_parts.size(); ll++){
-      for(unsigned kk=ll+1; kk<_top_parts.size(); kk++){
-	// define top_constituents candidate before filtering 	      
-	std::vector <PseudoJet> top_constits = _cs->constituents(_top_parts[rr]);
-	_cs->add_constituents(_top_parts[ll],top_constits);
-	_cs->add_constituents(_top_parts[kk],top_constits);	      
-
-	      // define Filtering: filt_top_R and jetdefinition 
-	double filt_top_R 
-	  = min(0.3,0.5*sqrt(min(_top_parts[kk].squared_distance(_top_parts[ll]),
-				 min(_top_parts[rr].squared_distance(_top_parts[ll]),
-				     _top_parts[kk].squared_distance(_top_parts[rr])))));
-	JetDefinition filtering_def(_jet_algorithm, filt_top_R);
-	std::vector<PseudoJet> top_constits_filtered = Filtering(top_constits,filtering_def);
-	PseudoJet topcandidate = Sum(top_constits_filtered);
-	if( topcandidate.m() < _mtmin || _mtmax < topcandidate.m() ) continue;
-	_top_count++;
-	// obtain 3 subjets
-	JetDefinition reclustering(_jet_algorithm_recluster, 3.14/2);
-	
-     //// **** NEXT 3 LINES EDITED CKV 12/2/12 **** (edit suggested by G. P. Salam)
-     ClusterSequence * cssubtop = new ClusterSequence(top_constits_filtered,reclustering);
-	std::vector <PseudoJet> top_subs = sorted_by_pt(cssubtop->exclusive_jets(3));	      
-	cssubtop->delete_self_when_unused();
-     //// **** END EDIT ***************************
-     
-     _candjets.push_back(top_subs); //
-	
-	// transfer infos of the positively identified top to the outer world 
-	double deltatop = abs(topcandidate.m() - _mtmass);
-	if(deltatop < _delta_top){	 
-	  _delta_top = deltatop;
-	  _is_maybe_top = true;
-	  _top_candidate = topcandidate;
-	  store_topsubjets(top_subs);
-	  _top_hadrons=top_constits_filtered;
-	  /////////////////////// check mass plane cut////////////////////////
-	  _is_masscut_passed=check_mass_criteria(top_subs);
-	}// end deltatop < _delta_top
-      }// end kk
-    }// end ll
-  }// end rr
-  return;
-}
-
-
-std::vector<fastjet::PseudoJet> HEPTopTagger::Filtering(const std::vector <PseudoJet> & top_constits, const JetDefinition & filtering_def)
-{
-  // perform filtering
-  fastjet::ClusterSequence cstopfilt( top_constits, filtering_def);
- 
-  // extract top subjets
-  std::vector<PseudoJet> filt_top_subjets = sorted_by_pt(cstopfilt.inclusive_jets());
-  
-  // take first n_topfilt subjets
-  std::vector<PseudoJet> top_constits_filtered;
-  for(unsigned ii = 0; ii<min(_nfilt, filt_top_subjets.size()) ; ii++)
-    {
-      cstopfilt.add_constituents(filt_top_subjets[ii],top_constits_filtered);
-    }
-  return top_constits_filtered;
-}
-
-
-fastjet::PseudoJet HEPTopTagger::Sum(const std::vector<PseudoJet> & vec_pjet)
-{
-  PseudoJet sum;
-  sum.reset(0.,0.,0.,0.);
-  for(unsigned i=0;i<vec_pjet.size();i++){
-    sum += vec_pjet.at(i);
-  }
-  return sum;
-}
-
-void HEPTopTagger::get_info() const
-{
-  cout << "maybe_top: " <<  _is_maybe_top << endl;
-  cout << "mascut_passed: " <<  _is_masscut_passed << endl;
-  cout << "top candidate mass:" <<  _top_candidate.m() << endl;
-  cout << "top candidate (pt, eta, phi): (" 
-       <<  _top_candidate.perp() << ","
-       <<  _top_candidate.eta() << ","
-       <<  _top_candidate.phi_std() << ")" << endl;
-  cout << "hadrons size: " <<  _top_hadrons.size() << endl;
-  cout << "topcount: " <<  _top_count << endl;
-  cout << "parts size: " <<  _parts_size << endl;
-  cout << "delta_top: " <<  _delta_top << endl;  
-  return;
-}
-
-
-void HEPTopTagger::get_setting() const
-{
-  cout << "top mass: " <<  _mtmass << endl;
-  cout << "W mass: " <<  _mwmass << endl;
-  cout << "top mass range: [" << _mtmin << ", " << _mtmax << "]" << endl;
-  cout << "W mass ratio range: [" << _rmin << ", " << _rmax << "] (["
-       <<_rmin*_mtmass/_mwmass<< "%, "<< _rmax*_mtmass/_mwmass << "%])"<< endl;
-  cout << "mass ratio cut: (m23cut, m13min, m13max)=(" 
-       << _m23cut << ", " << _m13cutmin << ", " << _m13cutmax << ")" << endl;
-  cout << "mass_drop_threshold: " << _mass_drop_threshold << endl;
-  cout << "max_subjet_mass: " << _max_subjet_mass << endl;
-  cout << "n_filtering: " << _nfilt << endl;
-  cout << "JetAlgorithm for filtering: "<< _jet_algorithm << endl;
-  cout << "JetAlgorithm for reclustering: "<< _jet_algorithm_recluster << endl;
-  return;
-}
-
-
-#endif // __HEPTOPTAGGER_HH__
+//HEPTopTagger: 
+// Modes:
+// 0 = EARLY_MASSRATIO_SORT_MASS (apply massratio, then sort by distance to true top mass)
+// 1 = LATE_MASSRATIO_SORT_MASS (sort by distance to true top mass, then apply mass-ratio. Old HTT)
+// 2 = EARLY_MASSRATIO_SORT_MODDJADE (apply massratio, then sort by modified d-jade)
+// 3 = LATE_MASSRATIO_SORT_MODDJADE (sort by modified d-jade, then apply mass-ratio)
+// 4 = TWO_STEP_FILTER (take three highest pT objects after unclustering and apply mass ratio)
+
+
+#ifndef __HEPTOPTAGGER_HH__
+#define __HEPTOPTAGGER_HH__
+
+#include <math.h>
+#include "fastjet/PseudoJet.hh"
+#include "fastjet/ClusterSequence.hh"
+#include "fastjet/tools/Pruner.hh"
+#include "fastjet/tools/Filter.hh"
+
+// Allow putting evertything into a separate namepsace
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+namespace external {
+
+
+class HEPTopTagger {
+
+public:
+
+  enum Mode {EARLY_MASSRATIO_SORT_MASS, 
+	     LATE_MASSRATIO_SORT_MASS, 
+	     EARLY_MASSRATIO_SORT_MODDJADE,
+	     LATE_MASSRATIO_SORT_MODDJADE,
+	     TWO_STEP_FILTER};
+
+  typedef fastjet::ClusterSequence ClusterSequence;
+  typedef fastjet::JetAlgorithm JetAlgorithm;
+  typedef fastjet::JetDefinition JetDefinition;
+  typedef fastjet::PseudoJet PseudoJet;
+
+  HEPTopTagger();
+  
+  HEPTopTagger(fastjet::PseudoJet jet);
+  
+  HEPTopTagger(fastjet::PseudoJet jet,
+	       double mtmass, double mwmass);
+
+  //run tagger
+  void run_tagger();
+  
+  //get information
+  bool is_maybe_top() const {return _is_maybe_top;}
+  bool is_masscut_passed() const {return _is_masscut_passed;}
+  bool is_minptcut_passed() const {return _is_ptmincut_passed;}
+  bool is_tagged() const {return (_is_masscut_passed && _is_ptmincut_passed);}
+  const PseudoJet & top_candidate() const {return _top_candidate;}
+  const std::vector<PseudoJet> & top_subjets() const {return _top_subjets;}
+  const std::vector<PseudoJet> & top_hadrons() const {return _top_hadrons;}
+  const std::vector<PseudoJet> & hardparts() const {return _top_parts;}
+  unsigned parts_size() const {return _parts_size;}
+  double delta_top() const {return _delta_top;}
+  double djsum() const {return _djsum;}
+  double pruned_mass() const {return _pruned_mass;}
+  double unfiltered_mass() const {return _unfiltered_mass;}
+  double fW();
+  void get_setting() const;
+  void get_info() const;
+  const PseudoJet & t() const {return _top_candidate;}
+  const PseudoJet & b() const {return _top_subjets[0];}
+  const PseudoJet & W() const {return _W;}
+  const PseudoJet & W1() const {return _top_subjets[1];}
+  const PseudoJet & W2() const {return _top_subjets[2];}
+  const PseudoJet & j1() const {return _top_subs[0];}
+  const PseudoJet & j2() const {return _top_subs[1];}
+  const PseudoJet & j3() const {return _top_subs[2];}
+  const PseudoJet & fat() {return _fat;}
+ 
+  //set parameters
+  void set_max_subjet_mass(double x) {_max_subjet_mass = x;}
+  void set_mass_drop_threshold(double x) {_mass_drop_threshold = x;}
+  void set_top_range(double xmin, double xmax) {_mtmin = xmin; _mtmax = xmax;}
+  void set_mass_ratio_range(double rmin, double rmax) {_rmin = rmin; _rmax = rmax;}
+  void set_mass_ratio_cut(double m23cut, double m13cutmin,double m13cutmax) {_m23cut = m23cut; _m13cutmin = m13cutmin; _m13cutmax = m13cutmax;}
+  void set_nfilt(unsigned nfilt) {_nfilt = nfilt;}
+  void set_Rfilt(double Rfilt) {_Rfilt = Rfilt;}
+  void set_filtering_jetalgorithm(JetAlgorithm jet_algorithm) {_jet_algorithm_filter = jet_algorithm;}
+  void set_reclustering_jetalgorithm(JetAlgorithm jet_algorithm) {_jet_algorithm_recluster = jet_algorithm;}
+  void set_pruner_cuts(double zcut, double rcut_factor) {_zcut = zcut; _rcut_factor = rcut_factor;}
+  void set_mode(int mode) {_mode = mode;}
+  void set_debug(bool debug) {_debug = debug;}
+  void set_minpt_tag(double x) {_minpt_tag = x;}
+  void set_minpt_subjet(double x) {_minpt_subjet = x;}
+  
+private:
+  const PseudoJet* _jet;
+  double _mtmass, _mwmass;
+  double _mass_drop_threshold;
+  double _max_subjet_mass;
+  double _mtmin, _mtmax;
+  double _rmin, _rmax;
+  double _m23cut, _m13cutmin, _m13cutmax;
+  size_t _nfilt;
+  double _Rfilt;
+  double _Rprun;
+  JetAlgorithm _jet_algorithm_filter;
+  JetAlgorithm _jet_algorithm_recluster;
+  double _zcut;
+  double _rcut_factor;
+  int _mode;
+  double _minpt_tag;
+  double _minpt_subjet;
+  bool _debug;
+  PseudoJet _fat;
+  
+  bool _is_masscut_passed;
+  bool _is_ptmincut_passed;
+  bool _is_maybe_top;
+  double _djsum;
+  double _delta_top;
+  double _pruned_mass;
+  double _unfiltered_mass;
+  double _fw;
+  unsigned _parts_size;
+  PseudoJet _top_candidate;
+  PseudoJet _W;
+  std::vector<PseudoJet> _top_subs;
+  std::vector<PseudoJet> _top_subjets;
+  std::vector<PseudoJet> _top_hadrons;
+  std::vector<PseudoJet> _top_parts;
+  static bool _first_time;
+
+  //internal functions
+  void FindHardSubst(const PseudoJet& jet, std::vector<fastjet::PseudoJet>& t_parts);
+  std::vector<PseudoJet> Filtering(const std::vector <PseudoJet> & top_constits, const JetDefinition & filtering_def);
+  void store_topsubjets(const std::vector<PseudoJet>& top_subs);
+  bool check_mass_criteria(const std::vector<fastjet::PseudoJet> & top_subs) const;
+  void print_banner();
+  double perp(const PseudoJet & vec, const fastjet::PseudoJet & ref);
+  double djademod (const fastjet::PseudoJet & subjet_i, const fastjet::PseudoJet & subjet_j, const fastjet::PseudoJet & ref);
+};
+//--------------------------------------------------------------------
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+};
+#endif // __HEPTOPTAGGER_HH__
diff --git a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
index 858fe63..0238882 100644
--- a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
@@ -39,25 +39,35 @@ FASTJET_BEGIN_NAMESPACE
 ///
 /// The HEP top tagger produces information similar to the Johns Hopkins tagger.
 ///  Accordingly I simply reuse the JHTopTaggerStructure.
+
+// Removed legacy comments by CHRISTOPHER SILKWORTH
+
 class HEPTopTaggerStructure;
 
 
 class HEPTopTagger : public TopTaggerBase {
 public:
-  /// Sets two of the algorithm parameters
-  ///
-  /// \param mass_drop_threshold    A splitting is hard if 
-  ///                                max(subjet_m) < mass_drop_threshold * m_child
-  /// \param max_subjet_mass        The tagger attempts to split subjets until
-  ///                                remaining subjets have m_subjet < max_subjet_mass.
-  /// \param use_subjet_mass_cuts   Whether to impose the subjet mass cuts described
-  ///                                in arXiv:1006.2833 (default=false)
-  /// Default values are taken from the original HepTopTagger.hh code.
-  HEPTopTagger(double mass_drop_threshold=0.8, double max_subjet_mass=30.,
-               bool use_subjet_mass_cuts=false)
-    : _mass_drop_threshold(mass_drop_threshold),
-      _max_subjet_mass(max_subjet_mass),
-      _use_subjet_mass_cuts(use_subjet_mass_cuts)
+  HEPTopTagger(double minSubjetPt, 
+	       double minCandPt, 
+	       double subjetMass, 
+	       double muCut, 
+	       int mode, 
+	       double minCandMass, 
+	       double maxCandMass, 
+	       double massRatioWidth, 
+	       double minM23Cut, 
+	       double minM13Cut, 
+	       double maxM13Cut) : minSubjetPt_(minSubjetPt),
+    minCandPt_(minCandPt),
+    subjetMass_(subjetMass),
+    muCut_(muCut),
+    mode_(mode),
+    minCandMass_(minCandMass),
+    maxCandMass_(maxCandMass),
+    massRatioWidth_(massRatioWidth),
+    minM23Cut_(minM23Cut),
+    minM13Cut_(minM13Cut),
+    maxM13Cut_(maxM13Cut)   
   {}
 
   /// returns a textual description of the tagger
@@ -73,59 +83,64 @@ public:
   typedef HEPTopTaggerStructure StructureType;
 
 private:
-  double _mass_drop_threshold;
-  double _max_subjet_mass;
-  bool _use_subjet_mass_cuts; ///< whether to include the is_masscut_passed() test
-};
-
-
-/// Basically just a copy of JHTopTaggerStructure, but this way HEPTopTagger can
-/// be a friend.
-
-//BEGIN COMMENTING OUT BY CHRISTOPHER SILKWORTH
-/*
-class HEPTopTaggerStructure : public JHTopTaggerStructure {
-public:
-  HEPTopTaggerStructure(std::vector<PseudoJet> pieces,
-      const JetDefinition::Recombiner *recombiner = 0)
-    : JHTopTaggerStructure(pieces, recombiner) {}
-
-protected:
-  friend class HEPTopTagger;
+    double minSubjetPt_; // Minimal pT for subjets [GeV]
+    double minCandPt_;   // Minimal pT to return a candidate [GeV]
+ 
+    double subjetMass_; // Mass above which subjets are further unclustered
+    double muCut_; // Mass drop threshold
+    
+    // HEPTopTagger Mode
+    // 0: do 2d-plane, return candidate with delta m_top minimal
+    // 1: return candidate with delta m_top minimal IF passes 2d plane
+    // 2: do 2d-plane, return candidate with max dj_sum
+    // 3: return candidate with max dj_sum IF passes 2d plane
+    // 4: return candidate built from leading three subjets after unclustering IF passes 2d plane
+    // Note: Original HTT was mode==1    
+    int mode_; 
+
+    // Top Quark mass window in GeV
+    double minCandMass_;
+    double maxCandMass_;
+    
+    double massRatioWidth_; // One sided width of the A-shaped window around m_W/m_top in %
+    double minM23Cut_; // minimal value of m23/m123
+    double minM13Cut_; // minimal value of atan(m13/m12)
+    double maxM13Cut_; // maximal value of atan(m13/m12)
 };
-*/
-//END COMMENTING OUT
-
-//BEGIN ADDED BY CHRISTOPHER SILKWORTH
 
 
 class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBaseStructure {
  public:
    /// ctor with pieces initialisation
    HEPTopTaggerStructure(const std::vector<PseudoJet>& pieces_in,
-                  const JetDefinition::Recombiner *recombiner = 0) :
-      CompositeJetStructure(pieces_in, recombiner), _cos_theta_w(0.0),W_rec(recombiner), 
-      rW_()
-	{}
- 
-   /// returns the W subjet
-      inline PseudoJet const & W() const{ 
-         rW_ = join(_pieces[0], _pieces[1], *W_rec);
-         return rW_;
-      }
+                  const JetDefinition::Recombiner *recombiner = 0) : CompositeJetStructure(pieces_in, recombiner),
+    _cos_theta_w(0.0),
+    _top_mass(0.0),
+    _unfiltered_mass(0.0),
+    _pruned_mass(0.0),
+    _fW(-1.),
+    _mass_ratio_passed(-1),
+    W_rec(recombiner), 
+    rW_(){}
+  
+   // Return W subjet
+   inline PseudoJet const & W() const{ 
+     rW_ = join(_pieces[0], _pieces[1], *W_rec);
+     return rW_;
+   }
+     
+   // Return leading subjet in W
+   inline PseudoJet  W1() const{
+     assert(W().pieces().size()>0);
+     return W().pieces()[0];
+   }
+       
+   /// returns the second W subjet
+   inline PseudoJet W2() const{
+     assert(W().pieces().size()>1);
+     return W().pieces()[1];
+   }
  
-      
-      inline PseudoJet  W1() const{
-         assert(W().pieces().size()>0);
-         return W().pieces()[0];
-      }
-      
-      /// returns the second W subjet
-      inline PseudoJet W2() const{
-         assert(W().pieces().size()>1);
-         return W().pieces()[1];
-      }
-
 
    /// returns the non-W subjet
    /// It will have 1 or 2 pieces depending on whether the tagger has
@@ -134,20 +149,33 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
      return _pieces[2];
    }
  
-   /// returns the W helicity angle
+   /// returns the W helicity angl
    inline double cos_theta_W() const {return _cos_theta_w;}
- 
- //  /// returns the original jet (before tagging)
- //  const PseudoJet & original() const {return _original_jet;}
 
- 
- 
+   /// returns the candidate mass
+   inline double top_mass() const {return _top_mass;}
+
+   /// returns the unfiltered mass
+   inline double unfiltered_mass() const {return _unfiltered_mass;}
+
+   /// returns the pruned mass
+   inline double pruned_mass() const {return _pruned_mass;}
+
+   /// returns fW
+   inline double fW() const {return _fW;}
+
+   /// returns if 2d-mass plane cuts were passed
+   inline double mass_ratio_passed() const {return _mass_ratio_passed;}
+    
  protected:
       double _cos_theta_w; ///< the W helicity angle
+      double _top_mass;
+      double _unfiltered_mass;
+      double _pruned_mass;
+      double _fW;
+      int _mass_ratio_passed;
+
       const JetDefinition::Recombiner  * W_rec;
-   //PseudoJet _W;             ///< the tagged W
-   //PseudoJet _non_W;         ///< the remaining pieces
- //  PseudoJet _original_jet;  ///< the original jet (before tagging)
  
       mutable PseudoJet rW_;
 
@@ -156,17 +184,24 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
  };
 
 
-//END ADDED BY CHRISTOPHER SILKWORTH
-
-
 //------------------------------------------------------------------------
 // description of the tagger
 inline std::string HEPTopTagger::description() const{ 
+
+  // TODO: FIXME!!!
   std::ostringstream oss;
-  oss << "HEPTopTagger with {max. subjet mass = " << _max_subjet_mass
-      << ", mass-drop threshold = " << _mass_drop_threshold
-      << ", and " << (_use_subjet_mass_cuts ? "using" : "not using") << " subjet mass cuts" << std::endl;
-  oss << description_of_selectors();
+  oss << "HEPTopTagger with: "
+      << "minSubjetPt = " << minSubjetPt_ 
+      << "minCandPt = " << minCandPt_ 
+      << "subjetMass = " << subjetMass_ 
+      << "muCut = " << muCut_ 
+      << "mode = " << mode_ 
+      << "minCandMass = " << minCandMass_ 
+      << "maxCandMass = " << maxCandMass_ 
+      << "massRatioWidth = " << massRatioWidth_ 
+      << "minM23Cut = " << minM23Cut_ 
+      << "minM13Cut = " << minM13Cut_ 
+      << "maxM13Cut = " << maxM13Cut_ << std::endl;
   return oss.str();
 }
 
diff --git a/RecoJets/JetAlgorithms/src/HEPTopTagger.cc b/RecoJets/JetAlgorithms/src/HEPTopTagger.cc
new file mode 100644
index 0000000..2c230bc
--- /dev/null
+++ b/RecoJets/JetAlgorithms/src/HEPTopTagger.cc
@@ -0,0 +1,350 @@
+
+#include "../interface/HEPTopTagger.h"
+
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+namespace external {
+
+bool HEPTopTagger::_first_time = true;
+
+void HEPTopTagger::print_banner() {
+  if (!_first_time) {return;}
+  _first_time = false;
+
+  std::cout << "#--------------------------------------------------------------------------\n";
+  std::cout << "#                   HEPTopTagger - under construction                      \n";
+  std::cout << "#                                                                          \n";
+  std::cout << "# Please cite JHEP 1010 (2010) 078 [arXiv:1006.2833 [hep-ph]]              \n";
+  std::cout << "# and Phys.Rev. D89 (2014) 074047 [arXiv:1312.1504 [hep-ph]]               \n";
+  std::cout << "#--------------------------------------------------------------------------\n";
+  get_setting();
+}
+
+double HEPTopTagger::perp(const PseudoJet & vec, const fastjet::PseudoJet & ref) {
+  double ref_ref = ref.px() * ref.px() + ref.py() * ref.py() + ref.pz() * ref.pz();
+  double vec_ref = vec.px() * ref.px() + vec.py() * ref.py() + vec.pz() * ref.pz();
+  double per_per = vec.px() * vec.px() + vec.py() * vec.py() + vec.pz() * vec.pz();
+  if (ref_ref > 0.) 
+    per_per -= vec_ref * vec_ref / ref_ref;
+  if (per_per < 0.) 
+    per_per = 0.;
+  return sqrt(per_per);
+}
+
+double HEPTopTagger::djademod (const fastjet::PseudoJet& subjet_i, const fastjet::PseudoJet& subjet_j, const fastjet::PseudoJet& ref) {
+  double dj = -1.0;
+  double delta_phi = subjet_i.delta_phi_to(subjet_j);
+  double delta_eta = subjet_i.eta() - subjet_j.eta();
+  double delta_R = sqrt(delta_eta * delta_eta + delta_phi * delta_phi);	
+  dj = perp(subjet_i, ref) * perp(subjet_j, ref) * pow(delta_R, 4.);
+  return dj;
+}
+
+double HEPTopTagger::fW() {
+  // Minimal:
+  // |(m_ij / m_123) / (m_w/ m_t) - 1|
+
+  double m12 = (_top_subs[0] + _top_subs[1]).m();
+  double m13 = (_top_subs[0] + _top_subs[2]).m();
+  double m23 = (_top_subs[1] + _top_subs[2]).m();
+  double m123 = (_top_subs[0] + _top_subs[1] + _top_subs[2]).m();
+
+  double fw12 = fabs( (m12/m123) / (_mwmass/_mtmass) - 1);
+  double fw13 = fabs( (m13/m123) / (_mwmass/_mtmass) - 1);
+  double fw23 = fabs( (m23/m123) / (_mwmass/_mtmass) - 1);
+  
+  return std::min(fw12, std::min(fw13, fw23));  
+}
+
+//Find hard substructures
+void HEPTopTagger::FindHardSubst(const PseudoJet & this_jet, std::vector<fastjet::PseudoJet> & t_parts) {
+  PseudoJet parent1(0, 0, 0, 0), parent2(0, 0, 0, 0);
+  if (this_jet.m() < _max_subjet_mass || !this_jet.validated_cs()->has_parents(this_jet, parent1, parent2)) {
+    t_parts.push_back(this_jet);
+  } else {
+    if (parent1.m() < parent2.m()) 
+      std::swap(parent1, parent2);   
+    FindHardSubst(parent1, t_parts);
+    if (parent1.m() < _mass_drop_threshold * this_jet.m())
+      FindHardSubst(parent2, t_parts);   
+  }
+}
+
+//store subjets as vector<PseudoJet> with [0]->b [1]->W-jet 1 [2]->W-jet 2
+void HEPTopTagger::store_topsubjets(const std::vector<PseudoJet>& top_subs) {
+  _top_subjets.resize(0);
+  double m12 = (top_subs[0] + top_subs[1]).m();
+  double m13 = (top_subs[0] + top_subs[2]).m();
+  double m23 = (top_subs[1] + top_subs[2]).m();
+  double dm12 = fabs(m12 - _mwmass);
+  double dm13 = fabs(m13 - _mwmass);
+  double dm23 = fabs(m23 - _mwmass);
+  
+  if (dm23 <= dm12 && dm23 <= dm13) {
+    _top_subjets.push_back(top_subs[0]); 
+    _top_subjets.push_back(top_subs[1]); 
+    _top_subjets.push_back(top_subs[2]);	
+  } else if (dm13 <= dm12 && dm13 < dm23) {
+    _top_subjets.push_back(top_subs[1]);
+    _top_subjets.push_back(top_subs[0]);
+    _top_subjets.push_back(top_subs[2]);
+  } else if (dm12 < dm23 && dm12 < dm13) {
+    _top_subjets.push_back(top_subs[2]);
+    _top_subjets.push_back(top_subs[0]);
+    _top_subjets.push_back(top_subs[1]);
+  }
+  _W = _top_subjets[1] + _top_subjets[2];
+  return;
+}
+
+//check mass plane cuts
+bool HEPTopTagger::check_mass_criteria(const std::vector<PseudoJet> & top_subs) const {
+  bool is_passed = false;
+  double m12 = (top_subs[0] + top_subs[1]).m();
+  double m13 = (top_subs[0] + top_subs[2]).m();
+  double m23 = (top_subs[1] + top_subs[2]).m();
+  double m123 = (top_subs[0] + top_subs[1] + top_subs[2]).m();
+  if (
+      (atan(m13/m12) > _m13cutmin && _m13cutmax > atan(m13/m12)
+       && (m23/m123 > _rmin && _rmax > m23/m123))
+      ||
+      (((m23/m123) * (m23/m123) < 1 - _rmin * _rmin* (1 + (m13/m12) * (m13/m12)))
+       &&
+       ((m23/m123) * (m23/m123) > 1 - _rmax * _rmax * (1 + (m13/m12) * (m13/m12)))
+       && 
+       (m23/m123 > _m23cut))
+      ||
+      (((m23/m123) * (m23/m123) < 1 - _rmin * _rmin * (1 + (m12/m13) * (m12/m13)))
+       &&
+       ((m23/m123) * (m23/m123) > 1 - _rmax * _rmax * (1 + (m12/m13) * (m12/m13)))
+       && 
+       (m23/m123 > _m23cut))
+      ) { 
+    is_passed = true;
+  }
+  return is_passed;
+}
+
+HEPTopTagger::HEPTopTagger() {}
+
+HEPTopTagger::HEPTopTagger(fastjet::PseudoJet jet) : 
+  _jet(&jet), _mtmass(172.3), _mwmass(80.4), 
+  _mass_drop_threshold(0.8), _max_subjet_mass(30.), 
+  _mtmin(150.), _mtmax(200.), _rmin(0.85*80.4/172.3), _rmax(1.15*80.4/172.3), 
+  _m23cut(0.35), _m13cutmin(0.2), _m13cutmax(1.3), 
+  _nfilt(5), _Rfilt(0.3), _Rprun(1.5), _jet_algorithm_filter(fastjet::cambridge_algorithm), _jet_algorithm_recluster(fastjet::cambridge_algorithm), _zcut(0.1),
+  _rcut_factor(0.5), _mode(0), _minpt_tag(200.), _minpt_subjet(0.), _debug(false), _fat(jet)
+{}
+
+HEPTopTagger::HEPTopTagger(fastjet::PseudoJet jet, 
+			   double mtmass, double mwmass
+			   ) : 
+  _jet(&jet), _mtmass(mtmass), _mwmass(mwmass), 
+  _mass_drop_threshold(0.8), _max_subjet_mass(30.), 
+  _mtmin(150.), _mtmax(200.), _rmin(0.85*mwmass/mtmass), _rmax(1.15*mwmass/mtmass), 
+  _m23cut(0.35), _m13cutmin(0.2), _m13cutmax(1.3), 
+  _nfilt(5), _Rfilt(0.3), _Rprun(1.5), _jet_algorithm_filter(fastjet::cambridge_algorithm), _jet_algorithm_recluster(fastjet::cambridge_algorithm), _zcut(0.1),
+  _rcut_factor(0.5), _mode(0), _minpt_tag(200.), _debug(false), _fat(jet)
+{}
+
+void HEPTopTagger::run_tagger() {
+  print_banner();
+
+  if ((_mode != Mode::EARLY_MASSRATIO_SORT_MASS) 
+      && (_mode != Mode::LATE_MASSRATIO_SORT_MASS) 
+      && (_mode != Mode::EARLY_MASSRATIO_SORT_MODDJADE)
+      && (_mode != Mode::LATE_MASSRATIO_SORT_MODDJADE)
+      && (_mode != Mode::TWO_STEP_FILTER) ) {
+    std::cout << "ERROR: UNKNOWN MODE" << std::endl;
+    return;
+  }
+  
+  //initialization
+  _djsum = 0.;
+  _delta_top = 1000000000000.0;
+  _pruned_mass = 0.;
+  _unfiltered_mass = 0.;
+  _top_candidate.reset(0., 0., 0., 0.);
+  _parts_size = 0;
+  _is_maybe_top = _is_masscut_passed = _is_ptmincut_passed = false;
+  _top_subs.clear();
+  _top_subjets.clear();
+  _top_hadrons.clear();
+  _top_parts.clear();
+  
+  //find hard substructures
+  FindHardSubst(*_jet, _top_parts);
+  _parts_size = _top_parts.size();
+  
+  if (_top_parts.size() < 3) { 
+    if (_debug) {std::cout << "< 3 hard substructures " << std::endl;}
+    return; //such events are not interesting   
+  }
+  
+  // Sort subjets-after-unclustering by pT.
+  // Necessary so that two-step-filtering can use the leading-three.
+  _top_parts=sorted_by_pt(_top_parts);
+
+  // loop over triples
+  _top_parts = sorted_by_pt(_top_parts);
+  for (unsigned rr = 0; rr < _top_parts.size(); rr++) {
+    for (unsigned ll = rr + 1; ll < _top_parts.size(); ll++) {
+      for (unsigned kk = ll + 1; kk < _top_parts.size(); kk++) {
+	
+	// two-step filtering 
+	// This means that we only look at the triplet formed by the
+	// three leading-in-pT subjets-after-unclustering.
+	if((_mode==Mode::TWO_STEP_FILTER) && rr>0)
+	  continue;
+	if((_mode==Mode::TWO_STEP_FILTER) && ll>1)
+	  continue;
+	if((_mode==Mode::TWO_STEP_FILTER) && kk>2)
+	  continue;
+
+      	//pick triple
+	PseudoJet triple = join(_top_parts[rr], _top_parts[ll], _top_parts[kk]);
+	
+	//filtering 
+	double filt_top_R 
+	  = std::min(_Rfilt, 0.5*sqrt(std::min(_top_parts[kk].squared_distance(_top_parts[ll]), 
+				     std::min(_top_parts[rr].squared_distance(_top_parts[ll]), 
+					 _top_parts[kk].squared_distance(_top_parts[rr])))));
+	JetDefinition filtering_def(_jet_algorithm_filter, filt_top_R);
+	fastjet::Filter filter(filtering_def, fastjet::SelectorNHardest(_nfilt) * fastjet::SelectorPtMin(_minpt_subjet));
+	PseudoJet topcandidate = filter(triple);
+
+
+	//mass window cut
+  	if (topcandidate.m() < _mtmin || _mtmax < topcandidate.m()) continue;
+
+	// Sanity cut: can't recluster less than 3 objects into three subjets
+	if (topcandidate.pieces().size() < 3)
+	  continue;
+       
+	// Recluster to 3 subjets and apply mass plane cuts
+	// Use a self-deleting CS-pointer. Taken from CMSSW version of HTT
+	// Initial CMSSW edit by CKV, suggested by G. P. Salam)	
+	JetDefinition reclustering(_jet_algorithm_recluster, 3.14);
+	ClusterSequence *  cs_top_sub = new ClusterSequence(topcandidate.pieces(), reclustering);
+        std::vector <PseudoJet> top_subs = sorted_by_pt(cs_top_sub->exclusive_jets(3));         
+	cs_top_sub->delete_self_when_unused();
+
+	// Require the third subjet to be above the pT threshold
+	if (top_subs[2].perp() < _minpt_subjet)
+	  continue;
+
+	// Modes with early 2d-massplane cuts
+	if (_mode == Mode::EARLY_MASSRATIO_SORT_MASS      && !check_mass_criteria(top_subs)) {continue;}
+	if (_mode == Mode::EARLY_MASSRATIO_SORT_MODDJADE  && !check_mass_criteria(top_subs)) {continue;}
+
+	//is this candidate better than the other? -> update
+	double deltatop = fabs(topcandidate.m() - _mtmass);
+	double djsum = djademod(top_subs[0], top_subs[1], topcandidate) 
+			       + djademod(top_subs[0], top_subs[2], topcandidate)
+			       + djademod(top_subs[1], top_subs[2], topcandidate);
+	bool better = false;
+
+	// Modes 0 and 1 sort by top mass
+	if ( (_mode == Mode::EARLY_MASSRATIO_SORT_MASS) 
+	     || (_mode == Mode::LATE_MASSRATIO_SORT_MASS)) {
+	  if (deltatop < _delta_top) 
+	    better = true;
+	}
+	// Modes 2 and 3 sort by modified jade distance
+	else if ( (_mode == Mode::EARLY_MASSRATIO_SORT_MODDJADE) 
+		  || (_mode == Mode::LATE_MASSRATIO_SORT_MODDJADE)) {
+	  if (djsum > _djsum) 
+	    better = true;
+	}
+	// Mode 4 is the two-step filtering. No sorting necessary as
+	// we just look at the triplet of highest pT objects after
+	// unclustering
+	else if (_mode == Mode::TWO_STEP_FILTER) {
+	  better = true;
+	} 
+	else {
+	  std::cout << "ERROR: UNKNOWN MODE (IN DISTANCE MEASURE SELECTION)" << std::endl;
+	  return;
+	}
+
+	if (better) {
+	  _djsum = djsum;
+	  _delta_top = deltatop; 
+	  _is_maybe_top = true;
+	  _top_candidate = topcandidate;
+	  _top_subs = top_subs;
+	  store_topsubjets(top_subs);
+	  _top_hadrons = topcandidate.constituents();
+	  //pruning
+	  JetDefinition jet_def_prune(fastjet::cambridge_algorithm, _Rprun);
+	  fastjet::Pruner pruner(jet_def_prune, _zcut, _rcut_factor);
+	  PseudoJet prunedjet = pruner(triple);
+	  _pruned_mass = prunedjet.m();
+	  _unfiltered_mass = triple.m();
+	  
+	  //are all criteria fulfilled?
+	  _is_masscut_passed = false;
+	  if (check_mass_criteria(top_subs)) {
+	    _is_masscut_passed = true;
+	  }
+	  _is_ptmincut_passed = false;
+	  if (_top_candidate.pt() > _minpt_tag) {
+	    _is_ptmincut_passed = true;
+	  }
+	}//end better
+      }//end kk
+    }//end ll
+  }//end rr
+  return;
+}
+
+void HEPTopTagger::get_info() const {  
+  std::cout << "#--------------------------------------------------------------------------\n";
+  std::cout << "#                          HEPTopTagger Result" << std::endl;
+  std::cout << "#" << std::endl;
+  std::cout << "# is top candidate: " << _is_maybe_top << std::endl;
+  std::cout << "# mass plane cuts passed: " << _is_masscut_passed << std::endl;
+  std::cout << "# top candidate mass: " << _top_candidate.m() << std::endl;
+  std::cout << "# top candidate (pt, eta, phi): (" 
+       << _top_candidate.perp() << ", "
+       << _top_candidate.eta() << ", "
+       << _top_candidate.phi_std() << ")" << std::endl;
+  std::cout << "# top hadrons: " << _top_hadrons.size() << std::endl;
+  std::cout << "# hard substructures: " << _parts_size << std::endl;
+  std::cout << "# |m - mtop| : " << _delta_top << std::endl; 
+  std::cout << "# djsum : " << _djsum << std::endl;
+  std::cout << "# is consistency cut passed: " << _is_ptmincut_passed << std::endl; 
+  std::cout << "#--------------------------------------------------------------------------\n";
+  return;
+}
+
+void HEPTopTagger::get_setting() const {
+  std::cout << "#--------------------------------------------------------------------------\n";
+  std::cout << "#                         HEPTopTagger Settings" << std::endl;
+  std::cout << "#" << std::endl;
+  std::cout << "# mode: " << _mode << " (0 = EARLY_MASSRATIO_SORT_MASS) " << std::endl;
+  std::cout << "#        "         << " (1 = LATE_MASSRATIO_SORT_MASS)  " << std::endl;
+  std::cout << "#        "         << " (2 = EARLY_MASSRATIO_SORT_MODDJADE)  " << std::endl;
+  std::cout << "#        "         << " (3 = LATE_MASSRATIO_SORT_MODDJADE)  " << std::endl;
+  std::cout << "#        "         << " (4 = TWO_STEP_FILTER)  " << std::endl;
+  std::cout << "# top mass: " << _mtmass << "    ";
+  std::cout << "W mass: " << _mwmass << std::endl;
+  std::cout << "# top mass window: [" << _mtmin << ", " << _mtmax << "]" << std::endl;
+  std::cout << "# W mass ratio: [" << _rmin << ", " << _rmax << "] (["
+       <<_rmin*_mtmass/_mwmass<< "%, "<< _rmax*_mtmass/_mwmass << "%])"<< std::endl;
+  std::cout << "# mass plane cuts: (m23cut, m13min, m13max) = (" 
+       << _m23cut << ", " << _m13cutmin << ", " << _m13cutmax << ")" << std::endl;
+  std::cout << "# mass_drop_threshold: " << _mass_drop_threshold << "    ";
+  std::cout << "max_subjet_mass: " << _max_subjet_mass << std::endl;
+  std::cout << "# R_filt: " << _Rfilt << "    ";
+  std::cout << "n_filt: " << _nfilt << std::endl;
+  std::cout << "# minimal subjet pt: " << _minpt_subjet << std::endl;
+  std::cout << "# minimal reconstructed pt: " << _minpt_tag << std::endl;
+  std::cout << "# internal jet algorithms (0 = kt, 1 = C/A, 2 = anti-kt): " << std::endl; 
+  std::cout << "#   filtering: "<< _jet_algorithm_filter << std::endl;
+  std::cout << "#   reclustering: "<< _jet_algorithm_recluster << std::endl;
+  std::cout << "#--------------------------------------------------------------------------\n";
+  
+  return;
+}
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+};
diff --git a/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
index 2d670fa..0c4823c 100644
--- a/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
@@ -22,15 +22,17 @@
 #include <fastjet/Error.hh>
 #include <fastjet/JetDefinition.hh>
 #include <fastjet/ClusterSequence.hh>
+#include "fastjet/PseudoJet.hh"
+#include "fastjet/tools/Pruner.hh"
+#include "fastjet/tools/Filter.hh"
 
+#include <math.h>
 #include <limits>
 #include <cassert>
 using namespace std;
 
-// namespace hack so that this tagger can have the same name as the core code
-namespace external {
 #include "RecoJets/JetAlgorithms/interface/HEPTopTagger.h"
-}
+
 
 FASTJET_BEGIN_NAMESPACE
 
@@ -38,6 +40,7 @@ FASTJET_BEGIN_NAMESPACE
 // returns the tagged PseudoJet if successful, 0 otherwise
 //  - jet   the PseudoJet to tag
 PseudoJet HEPTopTagger::result(const PseudoJet & jet) const{
+
   // make sure that there is a "regular" cluster sequence associated
   // with the jet. Note that we also check it is valid (to avoid a
   // more criptic error later on)
@@ -45,18 +48,37 @@ PseudoJet HEPTopTagger::result(const PseudoJet & jet) const{
     throw Error("HEPTopTagger can only be applied on jets having an associated (and valid) ClusterSequence");
   }
 
-  external::HEPTopTagger tagger(*jet.associated_cluster_sequence(), jet);
-  tagger.set_top_range(0.0, 10000.0); // don't do top mass cut; this can be applied later
-  tagger.set_mass_drop_threshold(_mass_drop_threshold);
-  tagger.set_max_subjet_mass(_max_subjet_mass);
+  external::HEPTopTagger tagger(jet);
 
-  tagger.run_tagger();
+  // translate the massRatioWidth (which should be the half-width given in %) 
+  // to values useful for the A-shape cuts
+  double mw_over_mt = 80.4/172.3;
+  double ratio_min = mw_over_mt * (100.-massRatioWidth_)/100.;
+  double ratio_max = mw_over_mt * (100.+massRatioWidth_)/100.;
+ 
   
-  // check that we passed the tagger; if not return a blank PseudoJet
-  if (_use_subjet_mass_cuts) {
-    if (!tagger.is_masscut_passed()) // encompasses is_maybe_top() plus subjet mass cuts
-      return PseudoJet();
-  } else if (!tagger.is_maybe_top())
+  // Unclustering, Filtering & Subjet Settings
+  tagger.set_max_subjet_mass(subjetMass_);
+  tagger.set_mass_drop_threshold(muCut_);
+  tagger.set_minpt_subjet(minSubjetPt_); 
+
+  // How to select among candidates
+  tagger.set_mode(mode_);
+  
+  // Requirements to accept a candidate
+  tagger.set_minpt_tag(minCandPt_); 
+  tagger.set_top_range(minCandMass_, maxCandMass_); 
+  tagger.set_mass_ratio_cut(minM23Cut_, minM13Cut_, maxM13Cut_);
+  tagger.set_mass_ratio_range(ratio_min, ratio_max);
+
+  tagger.run_tagger();
+
+  // Requires:
+  //   - top mass window
+  //   - mass ratio cuts
+  //   - minimal candidate pT
+  // If this is not intended: use loose top mass and ratio windows
+  if (!tagger.is_tagged())
     return PseudoJet();
   
   // create the result and its structure
@@ -71,24 +93,17 @@ PseudoJet HEPTopTagger::result(const PseudoJet & jet) const{
   PseudoJet W2 = subjets[2];
   PseudoJet W = join(subjets[1], subjets[2], *rec);
 
-
   PseudoJet result = join<HEPTopTaggerStructure>( W1, W2, non_W, *rec);
-  //HEPTopTaggerStructure *s = (HEPTopTaggerStructure*) result.structure_non_const_ptr();
-//  s->_cos_theta_w = _cos_theta_W(result);
-
-  // Check selectors to see if identified top, W pass and cuts
-  //
-  // Note that we could perhaps ensure this cut before constructing
-  // the result structure but this has the advantage that the top
-  // 4-vector is already available and does not have to de re-computed
-  if (! _top_selector.pass(result) || ! _W_selector.pass(W)) {
-    result *= 0.0;
-  }
+  HEPTopTaggerStructure *s = (HEPTopTaggerStructure*) result.structure_non_const_ptr();
+
+  s->_top_mass = tagger.t().m();
+  s->_pruned_mass = tagger.pruned_mass();
+  s->_unfiltered_mass = tagger.unfiltered_mass();
+  s->_fW = tagger.fW();
+  s->_mass_ratio_passed = tagger.is_masscut_passed();
 
+  // Removed selectors as all cuts are applied ion HTT
   return result;
 }
 
-
-
-
 FASTJET_END_NAMESPACE
diff --git a/RecoJets/JetProducers/plugins/CATopJetProducer.cc b/RecoJets/JetProducers/plugins/CATopJetProducer.cc
index f16b065..d81d7b4 100644
--- a/RecoJets/JetProducers/plugins/CATopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/CATopJetProducer.cc
@@ -45,15 +45,7 @@ CATopJetProducer::CATopJetProducer(edm::ParameterSet const& conf):
 						  conf.getParameter<double> ("rFrac"),
 						  conf.getParameter<double> ("adjacencyParam"))
 		);
-	}
-	else if (tagAlgo_ == FJ_HEP_TOPTAG ) {
-		fjHEPTopTagger_ = std::auto_ptr<fastjet::HEPTopTagger>(
-			new fastjet::HEPTopTagger(conf.getParameter<double>("muCut"),
-						  conf.getParameter<double>("maxSubjetMass"),
-						  conf.getParameter<bool>("useSubjetMass")
-						  )
-		);
-	}
+	}	
 	else if (tagAlgo_ == FJ_JHU_TOPTAG ) {
 		fjJHUTopTagger_ = std::auto_ptr<fastjet::JHTopTagger>(
 			new fastjet::JHTopTagger(conf.getParameter<double>("ptFrac"),
@@ -116,7 +108,6 @@ void CATopJetProducer::runAlgorithm( edm::Event& iEvent, const edm::EventSetup&
 	}
 
 	fastjet::CMSTopTagger & CMSTagger = *fjCMSTopTagger_;
-	fastjet::HEPTopTagger & HEPTagger = *fjHEPTopTagger_;
 	fastjet::JHTopTagger & JHUTagger = *fjJHUTopTagger_;
 	fastjet::RestFrameNSubjettinessTagger & NSUBTagger = *fjNSUBTagger_;
 
@@ -129,7 +120,6 @@ void CATopJetProducer::runAlgorithm( edm::Event& iEvent, const edm::EventSetup&
 
 		fastjet::PseudoJet taggedJet;
 		if (tagAlgo_ == FJ_CMS_TOPTAG) taggedJet = CMSTagger.result(*jetIt);
-		else if (tagAlgo_ == FJ_HEP_TOPTAG) taggedJet = HEPTagger.result(*jetIt);
 		else if (tagAlgo_ == FJ_JHU_TOPTAG) taggedJet = JHUTagger.result(*jetIt);
 		else if (tagAlgo_ == FJ_NSUB_TAG) taggedJet = NSUBTagger.result(*jetIt);
 		else cout << "NOT A VALID TAGGING ALGORITHM CHOICE!" << endl;
diff --git a/RecoJets/JetProducers/plugins/CATopJetProducer.h b/RecoJets/JetProducers/plugins/CATopJetProducer.h
index 0d09c30..e942edf 100644
--- a/RecoJets/JetProducers/plugins/CATopJetProducer.h
+++ b/RecoJets/JetProducers/plugins/CATopJetProducer.h
@@ -65,7 +65,6 @@
 #include "RecoJets/JetAlgorithms/interface/CATopJetAlgorithm.h"
 #include "CATopJetProducer.h"
 #include "RecoJets/JetAlgorithms/interface/CMSTopTagger.h"
-#include "RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h"
 
 #include <fastjet/tools/RestFrameNSubjettinessTagger.hh>
 #include "fastjet/SISConePlugin.hh"
@@ -88,7 +87,6 @@ namespace cms
   private:
     std::auto_ptr<CATopJetAlgorithm>        legacyCMSTopTagger_;         /// The algorithm to do the work
     std::auto_ptr<fastjet::CMSTopTagger>     fjCMSTopTagger_;    // The FastJet implementation of the CMS tagger
-    std::auto_ptr<fastjet::HEPTopTagger>     fjHEPTopTagger_;
     std::auto_ptr<fastjet::JHTopTagger>     fjJHUTopTagger_;
     std::auto_ptr<fastjet::RestFrameNSubjettinessTagger>   fjNSUBTagger_;
 
diff --git a/RecoJets/JetProducers/plugins/FastjetJetProducer.cc b/RecoJets/JetProducers/plugins/FastjetJetProducer.cc
index a2a23e7..6a1fd6b 100644
--- a/RecoJets/JetProducers/plugins/FastjetJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/FastjetJetProducer.cc
@@ -122,6 +122,10 @@ FastjetJetProducer::FastjetJetProducer(const edm::ParameterSet& iConfig)
     maxDepth_ = -1;
     useExplicitGhosts_ = true;
 
+    if ( iConfig.exists("writeCompound") ) {
+      std::cout << "Write Compound = " << iConfig.getParameter<bool>("writeCompound") << std::endl;
+    }
+
     if ( iConfig.exists("useMassDropTagger") ) {
       useMassDropTagger_ = iConfig.getParameter<bool>("useMassDropTagger");
       muCut_ = iConfig.getParameter<double>("muCut");
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
new file mode 100644
index 0000000..9100894
--- /dev/null
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -0,0 +1,184 @@
+#include "FWCore/Framework/interface/MakerMacros.h"
+#include "DataFormats/JetReco/interface/HTTTopJetTagInfo.h"
+#include "DataFormats/JetReco/interface/BasicJetCollection.h"
+#include "HTTTopJetProducer.h"
+
+using namespace edm;
+using namespace cms;
+using namespace reco;
+using namespace std;
+
+HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
+       FastjetJetProducer( conf ),
+       minFatjetPt_(200.),
+       minSubjetPt_(20.),
+       minCandPt_(200.),
+       maxFatjetAbsEta_(2.5),
+       subjetMass_(30.),
+       muCut_(0.8),
+       mode_(0),
+       minCandMass_(150.),
+       maxCandMass_(200.),
+       massRatioWidth_(0.15),
+       minM23Cut_(0.35),
+       minM13Cut_(0.2),
+       maxM13Cut_(1.3),
+       verbose_(false )
+{
+  
+  // Read in all the options from the configuration
+  if ( conf.exists("minFatjetPt") ) 
+    minFatjetPt_ = conf.getParameter<double>("minFatjetPt");
+  
+  if ( conf.exists("minSubjetPt") ) 
+    minSubjetPt_ = conf.getParameter<double>("minSubjetPt");
+  
+  if ( conf.exists("minCandPt") ) 
+    minCandPt_ = conf.getParameter<double>("minCandPt");
+  
+  if ( conf.exists("maxFatjetAbsEta") )
+    maxFatjetAbsEta_ = conf.getParameter<double>("maxFatjetAbsEta");
+  
+  if ( conf.exists("subjetMass") )
+    subjetMass_ = conf.getParameter<double>("subjetMass");
+  
+  if ( conf.exists("muCut") )
+    muCut_ = conf.getParameter<double>("muCut");
+  
+  if ( conf.exists("mode") )
+    mode_ = conf.getParameter<int>("mode");
+  
+  if ( conf.exists("minCandMass") )
+    minCandMass_ = conf.getParameter<double>("minCandMass");
+  
+  if ( conf.exists("maxCandMass") )
+    maxCandMass_ = conf.getParameter<double>("maxCandMass");
+  
+  if ( conf.exists("massRatioWidth") )
+    massRatioWidth_ = conf.getParameter<double>("massRatioWidth");
+  
+  if ( conf.exists("minM23Cut") )
+    minM23Cut_ = conf.getParameter<double>("minM23Cut");
+
+  if ( conf.exists("minM13Cut") )
+    minM13Cut_ = conf.getParameter<double>("minM13Cut");
+  
+  if ( conf.exists("maxM13Cut") )
+    maxM13Cut_ = conf.getParameter<double>("maxM13Cut");
+  
+  if ( conf.exists("verbose") )
+    verbose_ = conf.getParameter<bool>("verbose");
+  
+  // Create the tagger-wrapper
+  produces<HTTTopJetTagInfoCollection>();
+  fjHEPTopTagger_ = std::auto_ptr<fastjet::HEPTopTagger>(new fastjet::HEPTopTagger(minSubjetPt_, 
+										   minCandPt_,
+										   subjetMass_, 	    
+										   muCut_, 		    
+										   mode_, 		    
+										   minCandMass_, 	    
+										   maxCandMass_, 	    
+										   massRatioWidth_, 	    
+										   minM23Cut_, 	    
+										   minM13Cut_, 	    
+										   maxM13Cut_)); 
+  fromHTTTopJetProducer_ = 1;
+
+}
+
+		
+
+
+
+void HTTTopJetProducer::produce(  edm::Event & e, const edm::EventSetup & c ) 
+{
+  FastjetJetProducer::produce(e, c);
+}
+
+void HTTTopJetProducer::runAlgorithm( edm::Event& iEvent, const edm::EventSetup& iSetup)
+{
+
+  if ( !doAreaFastjet_ && !doRhoFastjet_) {
+    fjClusterSeq_ = ClusterSequencePtr( new fastjet::ClusterSequence( fjInputs_, *fjJetDefinition_ ) );
+  } else if (voronoiRfact_ <= 0) {
+    fjClusterSeq_ = ClusterSequencePtr( new fastjet::ClusterSequenceArea( fjInputs_, *fjJetDefinition_ , *fjAreaDefinition_ ) );
+  } else {
+    fjClusterSeq_ = ClusterSequencePtr( new fastjet::ClusterSequenceVoronoiArea( fjInputs_, *fjJetDefinition_ , fastjet::VoronoiAreaSpec(voronoiRfact_) ) );
+  }
+
+  //Run the jet clustering
+  vector<fastjet::PseudoJet> inclusiveJets = fjClusterSeq_->inclusive_jets(minFatjetPt_);
+
+  if ( verbose_ ) cout << "Getting central jets" << endl;
+  // Find the transient central jets
+  vector<fastjet::PseudoJet> centralJets;
+  for (unsigned int i = 0; i < inclusiveJets.size(); i++) {
+    
+    if (inclusiveJets[i].perp() > minFatjetPt_ && fabs(inclusiveJets[i].rapidity()) < maxFatjetAbsEta_) {
+      centralJets.push_back(inclusiveJets[i]);
+    }
+  }
+
+  fastjet::HEPTopTagger & HEPTagger = *fjHEPTopTagger_;
+
+  vector<fastjet::PseudoJet>::iterator jetIt = centralJets.begin(), centralJetsEnd = centralJets.end();
+  if ( verbose_ )cout<<"Loop over jets"<<endl;
+  for ( ; jetIt != centralJetsEnd; ++jetIt ) {
+    
+    if (verbose_) cout << "CMS FJ jet pt: " << (*jetIt).perp() << endl;
+    
+    fastjet::PseudoJet taggedJet;
+    taggedJet = HEPTagger.result(*jetIt);
+    
+    if (taggedJet != 0){
+      fjJets_.push_back(taggedJet);           
+    }
+  }
+  
+}
+
+void HTTTopJetProducer::addHTTTopJetTagInfoCollection( edm::Event& iEvent, 
+						       const edm::EventSetup& iSetup,
+						       edm::OrphanHandle<reco::BasicJetCollection> & oh){
+
+
+  // Set up output list
+  auto_ptr<HTTTopJetTagInfoCollection> tagInfos(new HTTTopJetTagInfoCollection() );
+
+  // Loop over jets
+  for (size_t ij=0; ij != fjJets_.size(); ij++){
+
+    HTTTopJetProperties properties;
+    HTTTopJetTagInfo tagInfo;
+
+    // Black magic:
+    // In the standard CA treatment the RefToBase is made from the handle directly
+    // Since we only have a OrphanHandle (the JetCollection is created by this process) 
+    // we have to take the detour via the Ref
+    edm::Ref<reco::BasicJetCollection> ref(oh, ij);  
+    edm::RefToBase<reco::Jet> rtb(ref);  
+    
+    fastjet::HEPTopTaggerStructure *s = (fastjet::HEPTopTaggerStructure*) fjJets_[ij].structure_non_const_ptr();
+
+    properties.topMass          = s->top_mass();
+    properties.unfilteredMass	= s->unfiltered_mass();
+    properties.prunedMass	= s->pruned_mass();
+    properties.fW		= s->fW();
+    properties.massRatioPassed  = s->mass_ratio_passed();
+
+    // Only needed for MultiR tagger
+    properties.isMultiR	        = 0;
+    properties.Rmin	        = -1.;
+    properties.RminExpected     = -1.;
+    
+    tagInfo.insert(rtb, properties );
+    tagInfos->push_back( tagInfo );
+  }  
+
+  iEvent.put( tagInfos );
+  
+};
+
+ 
+//define this as a plug-in
+DEFINE_FWK_MODULE(HTTTopJetProducer);
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
new file mode 100644
index 0000000..068157e
--- /dev/null
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
@@ -0,0 +1,131 @@
+#ifndef RecoJets_JetProducers_HTTTopJetProducer_h
+#define RecoJets_JetProducers_HTTTopJetProducer_h
+
+
+/* *********************************************************
+
+
+ * \class CATopJetProducer
+ * Jet producer to produce top jets using the C-A algorithm to break
+ * jets into subjets as described here:
+ * "Top-tagging: A Method for Identifying Boosted Hadronic Tops"
+ * David E. Kaplan, Keith Rehermann, Matthew D. Schwartz, Brock Tweedie
+ * arXiv:0806.0848v1 [hep-ph] 
+
+  \brief Jet producer to run the CATopJetAlgorithm
+
+  \author   Salvatore Rappoccio
+  \version  
+
+         Notes on implementation:
+
+	 Because the BaseJetProducer only allows the user to produce
+	 one jet collection at a time, this algorithm cannot
+	 fit into that paradigm. 
+
+	 All of the "hard" jets are of type BasicJet, since
+	 they are "jets of jets". The subjets will be either
+	 CaloJets, GenJets, etc.
+
+	 In order to avoid a templatization of the entire
+	 EDProducer itself, we only use a templated method
+	 to write out the subjets to the event record,
+	 and to use that information to write out the
+	 hard jets to the event record.
+
+	 This templated method is called "write_outputs". It
+	 relies on a second templated method called "write_specific",
+	 which relies on some template specialization to create
+	 different specific objects (i.e. CaloJets, BasicJets, GenJets, etc). 
+
+ ************************************************************/
+
+
+
+
+#include "FWCore/Framework/interface/Event.h"
+#include "FWCore/Framework/interface/EventSetup.h"
+#include "DataFormats/Common/interface/View.h"
+#include "DataFormats/Common/interface/Handle.h"
+#include "DataFormats/Provenance/interface/ProductID.h"
+#include "FWCore/MessageLogger/interface/MessageLogger.h"
+
+#include "DataFormats/JetReco/interface/CaloJetCollection.h"
+#include "DataFormats/JetReco/interface/GenJetCollection.h"
+#include "DataFormats/JetReco/interface/PFJetCollection.h"
+#include "DataFormats/JetReco/interface/BasicJetCollection.h"
+#include "RecoJets/JetAlgorithms/interface/JetAlgoHelper.h"
+#include "DataFormats/Candidate/interface/CandidateFwd.h"
+#include "DataFormats/Candidate/interface/LeafCandidate.h"
+#include "FWCore/Framework/interface/ESHandle.h"
+#include "Geometry/CaloGeometry/interface/CaloGeometry.h"
+#include "Geometry/Records/interface/CaloGeometryRecord.h"
+
+#include "RecoJets/JetProducers/plugins/FastjetJetProducer.h"
+
+
+#include "RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h"
+
+#include "fastjet/SISConePlugin.hh"
+
+
+namespace cms
+{
+  class HTTTopJetProducer : public FastjetJetProducer
+  {
+  public:
+
+    HTTTopJetProducer(const edm::ParameterSet& ps);
+
+    virtual ~HTTTopJetProducer() {}
+
+    virtual void produce( edm::Event& iEvent, const edm::EventSetup& iSetup );
+
+    virtual void runAlgorithm( edm::Event& iEvent, const edm::EventSetup& iSetup );
+
+    virtual void addHTTTopJetTagInfoCollection( edm::Event& iEvent, 
+						const edm::EventSetup& iSetup,
+						edm::OrphanHandle<reco::BasicJetCollection> & oh);
+
+
+  private:
+    std::auto_ptr<fastjet::HEPTopTagger>     fjHEPTopTagger_;
+
+    // Below are all configurable options. 
+    // Parenthesis indicates if this is enforced by the tagger itself or by the producer
+
+    double minFatjetPt_; // Only process fatjets larger pT with the tagger [GeV] (producer)
+    double minSubjetPt_; // Minimal pT for subjets [GeV] (tagger)
+    double minCandPt_;   // Minimal pT to return a candidate [GeV] (tagger)
+ 
+    double maxFatjetAbsEta_; // Only process fatjets with smaller |eta| with the tagger. (producer)
+
+    double subjetMass_; // Mass above which subjets are further unclustered (tagger)
+    double muCut_; // Mass drop threshold (tagger)
+    
+    // HEPTopTagger Mode (tagger):
+    // 0: do 2d-plane, return candidate with delta m_top minimal
+    // 1: return candidate with delta m_top minimal IF passes 2d plane
+    // 2: do 2d-plane, return candidate with max dj_sum
+    // 3: return candidate with max dj_sum IF passes 2d plane
+    // 4: return candidate built from leading three subjets after unclustering IF passes 2d plane
+    // Note: Original HTT was mode==1    
+    int mode_; 
+
+    // Top Quark mass window in GeV (tagger)
+    double minCandMass_;
+    double maxCandMass_;
+    
+    double massRatioWidth_; // One sided width of the A-shaped window around m_W/m_top in % (tagger)
+    double minM23Cut_; // minimal value of m23/m123 (tagger)
+    double minM13Cut_; // minimal value of atan(m13/m12) (tagger)
+    double maxM13Cut_; // maximal value of atan(m13/m12) (tagger)
+        
+    bool verbose_;
+
+  };
+
+}
+
+
+#endif
diff --git a/RecoJets/JetProducers/plugins/VirtualJetProducer.cc b/RecoJets/JetProducers/plugins/VirtualJetProducer.cc
index 7b242f1..c112d8b 100644
--- a/RecoJets/JetProducers/plugins/VirtualJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/VirtualJetProducer.cc
@@ -10,6 +10,10 @@
 #include "RecoJets/JetProducers/interface/BackgroundEstimator.h"
 #include "RecoJets/JetProducers/interface/VirtualJetProducerHelper.h"
 
+#include "DataFormats/Common/interface/RefProd.h"
+#include "DataFormats/Common/interface/Ref.h"
+#include "DataFormats/Common/interface/RefVector.h"
+
 #include "FWCore/Framework/interface/Event.h"
 #include "FWCore/Framework/interface/EventSetup.h"
 #include "FWCore/Framework/interface/ESHandle.h"
@@ -135,6 +139,7 @@ VirtualJetProducer::VirtualJetProducer(const edm::ParameterSet& iConfig)
   , jetCollInstanceName_ ("")
   , writeCompound_ ( false )
   , verbosity_(0)
+  , fromHTTTopJetProducer_(0)
 {
   anomalousTowerDef_ = std::auto_ptr<AnomalousTower>(new AnomalousTower(iConfig));
 
@@ -836,5 +841,11 @@ void VirtualJetProducer::writeCompoundJets(  edm::Event & iEvent, edm::EventSetu
   }
 
   // put hard jets into event record
-  iEvent.put( jetCollection);
+  // Store the Orphan handle for adding HTT information
+  edm::OrphanHandle<reco::BasicJetCollection>  oh = iEvent.put( jetCollection);
+
+  if (fromHTTTopJetProducer_){
+    addHTTTopJetTagInfoCollection( iEvent, iSetup, oh);
+  }
+
 }
diff --git a/RecoJets/JetProducers/plugins/VirtualJetProducer.h b/RecoJets/JetProducers/plugins/VirtualJetProducer.h
index 8838f38..7214771 100644
--- a/RecoJets/JetProducers/plugins/VirtualJetProducer.h
+++ b/RecoJets/JetProducers/plugins/VirtualJetProducer.h
@@ -12,6 +12,7 @@
 #include "DataFormats/JetReco/interface/PFJet.h"
 #include "DataFormats/JetReco/interface/BasicJet.h"
 #include "DataFormats/JetReco/interface/GenJet.h"
+#include "DataFormats/JetReco/interface/BasicJetCollection.h"
 
 #include "RecoJets/JetProducers/interface/PileUpSubtractor.h"
 #include "RecoJets/JetProducers/interface/AnomalousTower.h"
@@ -118,6 +119,11 @@ protected:
   // has no default. 
   virtual void runAlgorithm( edm::Event& iEvent, const edm::EventSetup& iSetup) = 0;
 
+  // This will allow making the HTTTopJetTagInfoCollection
+  virtual void addHTTTopJetTagInfoCollection( edm::Event& iEvent, 
+					      const edm::EventSetup& iSetup,
+					      edm::OrphanHandle<reco::BasicJetCollection> & oh){};
+ 
   // Do the offset correction. 
   // Only runs if "doPUOffsetCorrection_" is true.  
   void offsetCorrectJets(std::vector<fastjet::PseudoJet> & orphanInput);
@@ -175,7 +181,6 @@ protected:
   bool                  doPUOffsetCorr_;            // add the pileup calculation from offset correction? 
   std::string           puSubtractorName_;
 
-
   std::vector<edm::Ptr<reco::Candidate> > inputs_;  // input candidates [View, PtrVector and CandCollection have limitations]
   reco::Particle::Point           vertex_;          // Primary vertex 
   ClusterSequencePtr              fjClusterSeq_;    // fastjet cluster sequence
@@ -201,6 +206,9 @@ protected:
 
   int                   verbosity_;                 // flag to enable/disable debug output
 
+  bool                  fromHTTTopJetProducer_;   // for running the v2.0 HEPTopTagger
+
+
  private:
 
   std::auto_ptr<AnomalousTower>   anomalousTowerDef_;  // anomalous tower definition
diff --git a/RecoJets/JetProducers/python/CATopJetParameters_cfi.py b/RecoJets/JetProducers/python/CATopJetParameters_cfi.py
index ad16881..0810de1 100644
--- a/RecoJets/JetProducers/python/CATopJetParameters_cfi.py
+++ b/RecoJets/JetProducers/python/CATopJetParameters_cfi.py
@@ -4,7 +4,7 @@ import FWCore.ParameterSet.Config as cms
 # $Id
 CATopJetParameters = cms.PSet(
     jetCollInstanceName = cms.string("caTopSubJets"),	# subjet collection
-    verbose = cms.bool(False),          
+    verbose = cms.bool(True),          
     algorithm = cms.int32(1),               			# 0 = KT, 1 = CA, 2 = anti-KT
     tagAlgo = cms.int32(0),				#choice of top tagging algorithm
     useAdjacency = cms.int32(2),         				# veto adjacent subjets
-- 
1.8.3.1


From 372f6aa003599d8264afc666b4253c123ab36a0d Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Fri, 10 Oct 2014 14:10:20 +0200
Subject: [PATCH 02/22] Changed default value for massRatioWidth in
 HTTTopJetProducer.cc

---
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
index 9100894..430ab2e 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -19,7 +19,7 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
        mode_(0),
        minCandMass_(150.),
        maxCandMass_(200.),
-       massRatioWidth_(0.15),
+       massRatioWidth_(15),
        minM23Cut_(0.35),
        minM13Cut_(0.2),
        maxM13Cut_(1.3),
-- 
1.8.3.1


From 9daf0f0db784d2e7e566849265cf5ac32b51d348 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Fri, 10 Oct 2014 14:12:24 +0200
Subject: [PATCH 03/22] Removed writeCompound debug statement in
 FastjetJetProducer.cc

---
 RecoJets/JetProducers/plugins/FastjetJetProducer.cc | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/RecoJets/JetProducers/plugins/FastjetJetProducer.cc b/RecoJets/JetProducers/plugins/FastjetJetProducer.cc
index 6a1fd6b..a2a23e7 100644
--- a/RecoJets/JetProducers/plugins/FastjetJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/FastjetJetProducer.cc
@@ -122,10 +122,6 @@ FastjetJetProducer::FastjetJetProducer(const edm::ParameterSet& iConfig)
     maxDepth_ = -1;
     useExplicitGhosts_ = true;
 
-    if ( iConfig.exists("writeCompound") ) {
-      std::cout << "Write Compound = " << iConfig.getParameter<bool>("writeCompound") << std::endl;
-    }
-
     if ( iConfig.exists("useMassDropTagger") ) {
       useMassDropTagger_ = iConfig.getParameter<bool>("useMassDropTagger");
       muCut_ = iConfig.getParameter<double>("muCut");
-- 
1.8.3.1


From 452651e1650bfbf8b9a1a7fb65a29e14616c0a25 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Fri, 10 Oct 2014 14:13:10 +0200
Subject: [PATCH 04/22] Set default verbosity in CATopJetParameters_cfi.py back
 to false

---
 RecoJets/JetProducers/python/CATopJetParameters_cfi.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/RecoJets/JetProducers/python/CATopJetParameters_cfi.py b/RecoJets/JetProducers/python/CATopJetParameters_cfi.py
index 0810de1..ad16881 100644
--- a/RecoJets/JetProducers/python/CATopJetParameters_cfi.py
+++ b/RecoJets/JetProducers/python/CATopJetParameters_cfi.py
@@ -4,7 +4,7 @@ import FWCore.ParameterSet.Config as cms
 # $Id
 CATopJetParameters = cms.PSet(
     jetCollInstanceName = cms.string("caTopSubJets"),	# subjet collection
-    verbose = cms.bool(True),          
+    verbose = cms.bool(False),          
     algorithm = cms.int32(1),               			# 0 = KT, 1 = CA, 2 = anti-KT
     tagAlgo = cms.int32(0),				#choice of top tagging algorithm
     useAdjacency = cms.int32(2),         				# veto adjacent subjets
-- 
1.8.3.1


From 68227e8fd2ca3126c813d0f0defa286a11aa4093 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Tue, 14 Oct 2014 16:38:59 +0200
Subject: [PATCH 05/22] Started adding MultiR HTT

---
 .../JetAlgorithms/interface/MultiRHEPTopTagger.h   |  78 +++++++++++++
 RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc   | 126 +++++++++++++++++++++
 2 files changed, 204 insertions(+)
 create mode 100644 RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
 create mode 100644 RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc

diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
new file mode 100644
index 0000000..638705d
--- /dev/null
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
@@ -0,0 +1,78 @@
+//Adapted Version based on the work of Gregor.
+
+#ifndef __MULTIR_TOPTAGGER_HH__
+#define __MULTIR_TOPTAGGER_HH__
+
+#include <vector>
+#include <algorithm>  // for swap
+#include <math.h>
+#include "../interface/HEPTopTagger.h"
+
+using namespace std;
+using namespace fastjet;
+
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+namespace external {
+
+
+class MultiR_TopTagger {
+public:
+  MultiR_TopTagger(double max_fatjet_R,
+		   double min_fatjet_R,
+		   double step_R,
+		   double multiR_threshold,
+		   bool use_dR_max_triplet,
+		   fastjet::ClusterSequence & cs, 
+		   fastjet::PseudoJet & jet, 
+		   double mtmass, double mwmass
+		   );
+
+  ~MultiR_TopTagger();
+
+  //run tagger
+  void run_tagger();
+
+  const map<int,external::HEPTopTagger> & HTTagger() const {return _HEPTopTagger;}
+  external::HEPTopTagger HTTagger(int i)  {return _HEPTopTagger[i];}
+  
+  const map<int,int> & n_small_fatjets() const {return _n_small_fatjets;}
+  const double & Rmin() const {return _Rmin;}
+  const double & mass_Rmin() const {return _mass_Rmin;}
+  const double & pt_Rmin() const {return _pt_Rmin;}
+
+  void set_max_subjet_mass(double x) {_subjet_mass = x;}
+  void set_top_range(double top_range_min, double top_range_max) {_top_range[0] = top_range_min; _top_range[1] = top_range_max;}
+  void set_f_W(double f_W) {_f_W = f_W;}
+  void set_mass_ratio_cut(double mass_ratios_0, double mass_ratios_1, double mass_ratios_2) {_mass_ratios[0] = mass_ratios_0; _mass_ratios[1] = mass_ratios_1; _mass_ratios[2] = mass_ratios_2;}
+  void set_nfilt(unsigned nfilt) {_n_filt = nfilt;}
+  void set_Rfilt(double Rfilt) {_R_filt = Rfilt;}
+  void set_debug(bool debug) {_debug = debug;}
+ 
+
+private:
+  const ClusterSequence * _cs;
+  const PseudoJet *       _jet;
+  double _mtmass, _mwmass;
+  double _subjet_mass;
+  map<int,external::HEPTopTagger> _HEPTopTagger;
+  map<int,int> _n_small_fatjets;
+  double _Rmin, _mass_Rmin, _pt_Rmin;
+  double _mass_mean, _mass_width;
+  double _top_range[2];
+  unsigned _n_filt;
+  double _R_filt;
+  double _f_W;
+  double _mass_ratios[3];
+  double _max_fatjet_R, _min_fatjet_R, _step_R, _multiR_threshold;
+  bool _use_dR_max_triplet;
+  bool _debug;
+
+  void UnclusterFatjets(const vector<fastjet::PseudoJet> & big_fatjets, vector<fastjet::PseudoJet> & small_fatjets, const ClusterSequence & cs, const double small_radius);
+
+};
+//--------------------------------------------------------------------
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+};
+
+#endif // __MULTIR_TOPTAGGER_HH__
+
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
new file mode 100644
index 0000000..397abc6
--- /dev/null
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
@@ -0,0 +1,126 @@
+#include "../interface/MultiRHEPTopTagger.h"
+
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+namespace external {
+
+
+//uncluster a fat jet to subjets of given cone size
+void MultiR_TopTagger::UnclusterFatjets(const vector<fastjet::PseudoJet> & big_fatjets, 
+					vector<fastjet::PseudoJet> & small_fatjets, 
+					const ClusterSequence & cs, 
+					const double small_radius) {
+  for (unsigned i=0; i < big_fatjets.size(); i++) {
+    PseudoJet this_jet = big_fatjets[i];
+    PseudoJet parent1(0, 0, 0, 0), parent2(0, 0, 0, 0);
+    bool test = cs.has_parents(this_jet, parent1, parent2);
+    double dR = sqrt(parent1.squared_distance(parent2));
+
+    if (!test || dR<small_radius) {
+      small_fatjets.push_back(this_jet);
+    } else {
+      vector<fastjet::PseudoJet> parents;
+      parents.push_back(parent1);
+      parents.push_back(parent2);
+      UnclusterFatjets(parents, small_fatjets, cs, small_radius);
+    }
+  }
+}
+
+//////MultiR_TopTagger/////////////////////////
+//Start with a fatjet clustered with radius max_fatjet_R
+//Then run the HEPTopTagger for fatjets with smaller radii
+//Quantities stored as map<double,...> where the key is the fatjet radius
+
+MultiR_TopTagger::MultiR_TopTagger(double max_fatjet_R,
+				   double min_fatjet_R,
+				   double step_R,
+				   double multiR_threshold,
+				   bool use_dR_max_triplet,
+				   fastjet::ClusterSequence & cs, 
+				   fastjet::PseudoJet & jet, 
+				   double mtmass, double mwmass
+				   ) : _cs(&cs),  _jet(&jet),
+				       _mtmass(mtmass),	_mwmass(mwmass), _max_fatjet_R(max_fatjet_R), _min_fatjet_R(min_fatjet_R), _step_R(step_R), _multiR_threshold(multiR_threshold), _use_dR_max_triplet(use_dR_max_triplet), _debug(false)
+{}
+
+void MultiR_TopTagger::run_tagger() {
+  if (_debug) {
+    cout << "============================="  << endl 
+	 << "new MultiR" << endl;
+  }
+  
+  vector<fastjet::PseudoJet> big_fatjets;
+  vector<fastjet::PseudoJet> small_fatjets;
+  
+  big_fatjets.push_back(* _jet);
+  _Rmin = 0;
+  _mass_Rmin = 0.;
+  _pt_Rmin = 0.;
+
+  int maxR = int(_max_fatjet_R * 10);
+  int minR = int(_min_fatjet_R * 10);
+  int stepR = int(_step_R * 10);
+
+  for (int R = maxR; R >= minR; R -= stepR) {
+
+    // Deactivated this piece for now as dR_max_triplet is not used.
+    // Problem in lines below?
+    //  
+    //float dR_max_triplet = 9999;
+    //if (_use_dR_max_triplet) {
+    //  small_fatjets = big_fatjets;
+    //  dR_max_triplet = R / 10.;   
+    //} else {
+
+    UnclusterFatjets(big_fatjets, small_fatjets, *_cs, R / 10.);
+    //}
+    
+    if (_debug) {cout << "R = " << R << " -> n_small_fatjets = " << small_fatjets.size();}
+    
+    _n_small_fatjets[R] = small_fatjets.size();
+    double dummy = 1000000000000.0;
+
+    for (unsigned i = 0; i < small_fatjets.size(); i++) {
+      external::HEPTopTagger htt(small_fatjets[i], _mtmass, _mwmass);
+      htt.set_top_range(_top_range[0], _top_range[1]);
+      htt.set_mass_ratio_cut(_mass_ratios[0], _mass_ratios[1], _mass_ratios[2]);
+      htt.set_max_subjet_mass(_subjet_mass);
+      htt.set_nfilt(_n_filt);
+      htt.set_Rfilt(_R_filt);
+      htt.set_mass_ratio_range((1.-_f_W)*_mwmass/_mtmass, (1.+_f_W)*_mwmass/_mtmass); 
+      htt.set_mode(1);	
+      
+      htt.run_tagger();
+     
+      double deltatop = fabs(htt.top_candidate().m() - _mtmass);
+      if (deltatop < dummy) {
+	dummy = deltatop;
+	_HEPTopTagger[R] = htt;
+      }
+    } //End of loop over small_fatjets
+    
+    if (_Rmin == 0 && R < maxR) {
+      double delta_m = fabs(_HEPTopTagger[maxR].top_candidate().m() - _HEPTopTagger[R].top_candidate().m());
+      if (delta_m > _multiR_threshold*_HEPTopTagger[maxR].top_candidate().m() || _HEPTopTagger[R].top_candidate().m() == 0) {
+	_Rmin = R + 1;
+      }
+    }
+    
+    big_fatjets = small_fatjets;
+    small_fatjets.clear();
+
+  }//End of loop over R
+
+  if (_Rmin == 0 && _HEPTopTagger[maxR].top_candidate().m() > 0)
+    _Rmin = 5;
+
+  _mass_Rmin = _HEPTopTagger[_Rmin].top_candidate().m();
+  _pt_Rmin = _HEPTopTagger[_Rmin].top_candidate().perp();
+ 
+  if (_debug) {cout << "MultiR done" << endl;}
+}
+
+MultiR_TopTagger::~MultiR_TopTagger(){}
+
+// Do not change next line, it's needed by the sed-code that makes the tagger CMSSW-compatible.
+};
-- 
1.8.3.1


From 4a7f7a7976811140fc30647420a0de6376af5ec4 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Wed, 15 Oct 2014 10:46:16 +0200
Subject: [PATCH 06/22] working on MultiR wrappers

---
 .../JetAlgorithms/interface/MultiRHEPTopTagger.h   |  16 +-
 .../interface/MultiRHEPTopTaggerWrapper.h          | 195 +++++++++++++++++++++
 RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc   |   7 +-
 .../JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc | 107 +++++++++++
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc |   5 +
 RecoJets/JetProducers/plugins/HTTTopJetProducer.h  |   2 +
 6 files changed, 323 insertions(+), 9 deletions(-)
 create mode 100644 RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
 create mode 100644 RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc

diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
index 638705d..2a78950 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
@@ -32,13 +32,16 @@ public:
   //run tagger
   void run_tagger();
 
-  const map<int,external::HEPTopTagger> & HTTagger() const {return _HEPTopTagger;}
-  external::HEPTopTagger HTTagger(int i)  {return _HEPTopTagger[i];}
-  
-  const map<int,int> & n_small_fatjets() const {return _n_small_fatjets;}
-  const double & Rmin() const {return _Rmin;}
+  // Return the candidate (and some properties) at R=R_min
+  external::HEPTopTagger cand_Rmin(){return _HEPTopTagger[_Rmin];}
+  const int & Rmin_raw() const {return _Rmin;}
+  const double Rmin() const {return _Rmin/10.;}
   const double & mass_Rmin() const {return _mass_Rmin;}
   const double & pt_Rmin() const {return _pt_Rmin;}
+  
+  // Access to all candidates and number-of-small-fatjets
+  external::HEPTopTagger HTTagger(int i)  {return _HEPTopTagger[i];}
+  const double n_small_fatjets(int i) {return _n_small_fatjets[i];}
 
   void set_max_subjet_mass(double x) {_subjet_mass = x;}
   void set_top_range(double top_range_min, double top_range_max) {_top_range[0] = top_range_min; _top_range[1] = top_range_max;}
@@ -56,7 +59,8 @@ private:
   double _subjet_mass;
   map<int,external::HEPTopTagger> _HEPTopTagger;
   map<int,int> _n_small_fatjets;
-  double _Rmin, _mass_Rmin, _pt_Rmin;
+  int _Rmin;
+  double _mass_Rmin, _pt_Rmin;
   double _mass_mean, _mass_width;
   double _top_range[2];
   unsigned _n_filt;
diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
new file mode 100644
index 0000000..90953ed
--- /dev/null
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
@@ -0,0 +1,195 @@
+//----------------------------------------------------------------------
+//  This file is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This file is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  The GNU General Public License is available at
+//  http://www.gnu.org/licenses/gpl.html or you can write to the Free Software
+//  Foundation, Inc.:
+//      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//----------------------------------------------------------------------
+
+#ifndef __MULTIRHEPTOPTAGGER_WRAPPER_HH__
+#define __MULTIRHEPTOPTAGGER_WRAPPER_HH__
+
+#include <fastjet/tools/TopTaggerBase.hh>
+#include <fastjet/CompositeJetStructure.hh>
+#include <sstream>
+
+FASTJET_BEGIN_NAMESPACE
+
+// Based on HEPTopTaggerWrapper.h
+
+class MultiRHEPTopTaggerStructure;
+
+class MultiRHEPTopTagger : public TopTaggerBase {
+public:
+  MultiRHEPTopTagger(double minSubjetPt, 
+		     double minCandPt, 
+		     double subjetMass, 
+		     double muCut, 
+		     int mode, 
+		     double minCandMass, 
+		     double maxCandMass, 
+		     double massRatioWidth, 
+		     double minM23Cut, 
+		     double minM13Cut, 
+		     double maxM13Cut) : minSubjetPt_(minSubjetPt),
+    minCandPt_(minCandPt),
+    subjetMass_(subjetMass),
+    muCut_(muCut),
+    mode_(mode),
+    minCandMass_(minCandMass),
+    maxCandMass_(maxCandMass),
+    massRatioWidth_(massRatioWidth),
+    minM23Cut_(minM23Cut),
+    minM13Cut_(minM13Cut),
+    maxM13Cut_(maxM13Cut)   
+  {}
+
+  /// returns a textual description of the tagger
+  virtual std::string description() const;
+
+  /// runs the tagger on the given jet and
+  /// returns the tagged PseudoJet if successful, or a PseudoJet==0 otherwise
+  /// (standard access is through operator()).
+  ///  \param jet   the PseudoJet to tag
+  virtual PseudoJet result(const PseudoJet & jet) const;
+
+  // the type of the associated structure
+  typedef MultiRHEPTopTaggerStructure StructureType;
+
+private:
+    double minSubjetPt_; // Minimal pT for subjets [GeV]
+    double minCandPt_;   // Minimal pT to return a candidate [GeV]
+ 
+    double subjetMass_; // Mass above which subjets are further unclustered
+    double muCut_; // Mass drop threshold
+    
+    // HEPTopTagger Mode
+    // 0: do 2d-plane, return candidate with delta m_top minimal
+    // 1: return candidate with delta m_top minimal IF passes 2d plane
+    // 2: do 2d-plane, return candidate with max dj_sum
+    // 3: return candidate with max dj_sum IF passes 2d plane
+    // 4: return candidate built from leading three subjets after unclustering IF passes 2d plane
+    // Note: Original HTT was mode==1    
+    int mode_; 
+
+    // Top Quark mass window in GeV
+    double minCandMass_;
+    double maxCandMass_;
+    
+    double massRatioWidth_; // One sided width of the A-shaped window around m_W/m_top in %
+    double minM23Cut_; // minimal value of m23/m123
+    double minM13Cut_; // minimal value of atan(m13/m12)
+    double maxM13Cut_; // maximal value of atan(m13/m12)
+};
+
+
+class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBaseStructure {
+ public:
+   /// ctor with pieces initialisation
+   MultiRHEPTopTaggerStructure(const std::vector<PseudoJet>& pieces_in,
+                  const JetDefinition::Recombiner *recombiner = 0) : CompositeJetStructure(pieces_in, recombiner),
+    _cos_theta_w(0.0),
+    _top_mass(0.0),
+    _unfiltered_mass(0.0),
+    _pruned_mass(0.0),
+    _fW(-1.),
+    _mass_ratio_passed(-1),
+    W_rec(recombiner), 
+    rW_(){}
+  
+   // Return W subjet
+   inline PseudoJet const & W() const{ 
+     rW_ = join(_pieces[0], _pieces[1], *W_rec);
+     return rW_;
+   }
+     
+   // Return leading subjet in W
+   inline PseudoJet  W1() const{
+     assert(W().pieces().size()>0);
+     return W().pieces()[0];
+   }
+       
+   /// returns the second W subjet
+   inline PseudoJet W2() const{
+     assert(W().pieces().size()>1);
+     return W().pieces()[1];
+   }
+ 
+
+   /// returns the non-W subjet
+   /// It will have 1 or 2 pieces depending on whether the tagger has
+   /// found 3 or 4 pieces
+   inline const PseudoJet & non_W() const{ 
+     return _pieces[2];
+   }
+ 
+   /// returns the W helicity angl
+   inline double cos_theta_W() const {return _cos_theta_w;}
+
+   /// returns the candidate mass
+   inline double top_mass() const {return _top_mass;}
+
+   /// returns the unfiltered mass
+   inline double unfiltered_mass() const {return _unfiltered_mass;}
+
+   /// returns the pruned mass
+   inline double pruned_mass() const {return _pruned_mass;}
+
+   /// returns fW
+   inline double fW() const {return _fW;}
+
+   /// returns if 2d-mass plane cuts were passed
+   inline double mass_ratio_passed() const {return _mass_ratio_passed;}
+    
+ protected:
+      double _cos_theta_w; ///< the W helicity angle
+      double _top_mass;
+      double _unfiltered_mass;
+      double _pruned_mass;
+      double _fW;
+      int _mass_ratio_passed;
+
+      const JetDefinition::Recombiner  * W_rec;
+ 
+      mutable PseudoJet rW_;
+
+   // allow the tagger to set these
+   friend class HEPTopTagger;
+   friend class MultiRHEPTopTagger;
+ };
+
+
+//------------------------------------------------------------------------
+// description of the tagger
+inline std::string MultiRHEPTopTagger::description() const{ 
+
+  // TODO: FIXME!!!
+  std::ostringstream oss;
+  oss << "MultiRHEPTopTagger with: "
+      << "minSubjetPt = " << minSubjetPt_ 
+      << "minCandPt = " << minCandPt_ 
+      << "subjetMass = " << subjetMass_ 
+      << "muCut = " << muCut_ 
+      << "mode = " << mode_ 
+      << "minCandMass = " << minCandMass_ 
+      << "maxCandMass = " << maxCandMass_ 
+      << "massRatioWidth = " << massRatioWidth_ 
+      << "minM23Cut = " << minM23Cut_ 
+      << "minM13Cut = " << minM13Cut_ 
+      << "maxM13Cut = " << maxM13Cut_ << std::endl;
+  return oss.str();
+}
+
+
+FASTJET_END_NAMESPACE
+
+#endif // __MULTIRHEPTOPTAGGER_HH__
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
index 397abc6..b0ef169 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
@@ -62,7 +62,8 @@ void MultiR_TopTagger::run_tagger() {
   int stepR = int(_step_R * 10);
 
   for (int R = maxR; R >= minR; R -= stepR) {
-
+    
+    // TODO: check!
     // Deactivated this piece for now as dR_max_triplet is not used.
     // Problem in lines below?
     //  
@@ -102,7 +103,7 @@ void MultiR_TopTagger::run_tagger() {
     if (_Rmin == 0 && R < maxR) {
       double delta_m = fabs(_HEPTopTagger[maxR].top_candidate().m() - _HEPTopTagger[R].top_candidate().m());
       if (delta_m > _multiR_threshold*_HEPTopTagger[maxR].top_candidate().m() || _HEPTopTagger[R].top_candidate().m() == 0) {
-	_Rmin = R + 1;
+	_Rmin = R + stepR;
       }
     }
     
@@ -112,7 +113,7 @@ void MultiR_TopTagger::run_tagger() {
   }//End of loop over R
 
   if (_Rmin == 0 && _HEPTopTagger[maxR].top_candidate().m() > 0)
-    _Rmin = 5;
+    _Rmin = minR;
 
   _mass_Rmin = _HEPTopTagger[_Rmin].top_candidate().m();
   _pt_Rmin = _HEPTopTagger[_Rmin].top_candidate().perp();
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
new file mode 100644
index 0000000..1696e1a
--- /dev/null
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
@@ -0,0 +1,107 @@
+//----------------------------------------------------------------------
+//  This file is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This file is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  The GNU General Public License is available at
+//  http://www.gnu.org/licenses/gpl.html or you can write to the Free Software
+//  Foundation, Inc.:
+//      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//----------------------------------------------------------------------
+
+#include "RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h"
+
+#include <fastjet/Error.hh>
+#include <fastjet/JetDefinition.hh>
+#include <fastjet/ClusterSequence.hh>
+#include "fastjet/PseudoJet.hh"
+#include "fastjet/tools/Pruner.hh"
+#include "fastjet/tools/Filter.hh"
+
+#include <math.h>
+#include <limits>
+#include <cassert>
+using namespace std;
+
+#include "RecoJets/JetAlgorithms/interface/HEPTopTagger.h"
+#include "RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h"
+
+FASTJET_BEGIN_NAMESPACE
+
+//------------------------------------------------------------------------
+// returns the tagged PseudoJet if successful, 0 otherwise
+//  - jet   the PseudoJet to tag
+PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
+
+  // make sure that there is a "regular" cluster sequence associated
+  // with the jet. Note that we also check it is valid (to avoid a
+  // more criptic error later on)
+  if (!jet.has_valid_cluster_sequence()){
+    throw Error("HEPTopTagger can only be applied on jets having an associated (and valid) ClusterSequence");
+  }
+
+  external::HEPTopTagger tagger(jet);
+
+  // translate the massRatioWidth (which should be the half-width given in %) 
+  // to values useful for the A-shape cuts
+  double mw_over_mt = 80.4/172.3;
+  double ratio_min = mw_over_mt * (100.-massRatioWidth_)/100.;
+  double ratio_max = mw_over_mt * (100.+massRatioWidth_)/100.;
+ 
+  
+  // Unclustering, Filtering & Subjet Settings
+  tagger.set_max_subjet_mass(subjetMass_);
+  tagger.set_mass_drop_threshold(muCut_);
+  tagger.set_minpt_subjet(minSubjetPt_); 
+
+  // How to select among candidates
+  tagger.set_mode(mode_);
+  
+  // Requirements to accept a candidate
+  tagger.set_minpt_tag(minCandPt_); 
+  tagger.set_top_range(minCandMass_, maxCandMass_); 
+  tagger.set_mass_ratio_cut(minM23Cut_, minM13Cut_, maxM13Cut_);
+  tagger.set_mass_ratio_range(ratio_min, ratio_max);
+
+  tagger.run_tagger();
+
+  // Requires:
+  //   - top mass window
+  //   - mass ratio cuts
+  //   - minimal candidate pT
+  // If this is not intended: use loose top mass and ratio windows
+  if (!tagger.is_tagged())
+    return PseudoJet();
+  
+  // create the result and its structure
+  const JetDefinition::Recombiner *rec
+    = jet.associated_cluster_sequence()->jet_def().recombiner();
+
+  const vector<PseudoJet>& subjets = tagger.top_subjets();
+  assert(subjets.size() == 3);
+
+  PseudoJet non_W = subjets[0];
+  PseudoJet W1 = subjets[1];
+  PseudoJet W2 = subjets[2];
+  PseudoJet W = join(subjets[1], subjets[2], *rec);
+
+  PseudoJet result = join<MultiRHEPTopTaggerStructure>( W1, W2, non_W, *rec);
+  MultiRHEPTopTaggerStructure *s = (MultiRHEPTopTaggerStructure*) result.structure_non_const_ptr();
+
+  s->_top_mass = tagger.t().m();
+  s->_pruned_mass = tagger.pruned_mass();
+  s->_unfiltered_mass = tagger.unfiltered_mass();
+  s->_fW = tagger.fW();
+  s->_mass_ratio_passed = tagger.is_masscut_passed();
+
+  // Removed selectors as all cuts are applied ion HTT
+  return result;
+}
+
+FASTJET_END_NAMESPACE
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
index 430ab2e..363f1ef 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -10,6 +10,7 @@ using namespace std;
 
 HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
        FastjetJetProducer( conf ),
+       multiR_(false),
        minFatjetPt_(200.),
        minSubjetPt_(20.),
        minCandPt_(200.),
@@ -27,6 +28,9 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
 {
   
   // Read in all the options from the configuration
+  if ( conf.exists("multiR") ) 
+    multiR_ = conf.getParameter<bool>("multiR");
+
   if ( conf.exists("minFatjetPt") ) 
     minFatjetPt_ = conf.getParameter<double>("minFatjetPt");
   
@@ -71,6 +75,7 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
   
   // Create the tagger-wrapper
   produces<HTTTopJetTagInfoCollection>();
+
   fjHEPTopTagger_ = std::auto_ptr<fastjet::HEPTopTagger>(new fastjet::HEPTopTagger(minSubjetPt_, 
 										   minCandPt_,
 										   subjetMass_, 	    
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
index 068157e..6326a98 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
@@ -94,6 +94,8 @@ namespace cms
     // Below are all configurable options. 
     // Parenthesis indicates if this is enforced by the tagger itself or by the producer
 
+    bool multiR_; // Should the MultiR version of the tagger be used? (producer)
+
     double minFatjetPt_; // Only process fatjets larger pT with the tagger [GeV] (producer)
     double minSubjetPt_; // Minimal pT for subjets [GeV] (tagger)
     double minCandPt_;   // Minimal pT to return a candidate [GeV] (tagger)
-- 
1.8.3.1


From e7d2302229d3573454b8022aecc96401a3fc626a Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Thu, 16 Oct 2014 14:35:09 +0200
Subject: [PATCH 07/22] Working MultiR version based on
 37e0db4ced95efcf8723ba862a4f1d6df3e8afb2

---
 .../JetAlgorithms/interface/MultiRHEPTopTagger.h   | 13 ++-
 .../interface/MultiRHEPTopTaggerWrapper.h          |  8 +-
 RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc   | 21 +++--
 .../JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc | 57 +++++++------
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc | 95 +++++++++++++++-------
 RecoJets/JetProducers/plugins/HTTTopJetProducer.h  |  5 +-
 6 files changed, 131 insertions(+), 68 deletions(-)

diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
index 2a78950..9cb4475 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
@@ -22,8 +22,8 @@ public:
 		   double step_R,
 		   double multiR_threshold,
 		   bool use_dR_max_triplet,
-		   fastjet::ClusterSequence & cs, 
-		   fastjet::PseudoJet & jet, 
+		   const fastjet::ClusterSequence & cs, 
+		   const fastjet::PseudoJet & jet, 
 		   double mtmass, double mwmass
 		   );
 
@@ -43,7 +43,12 @@ public:
   external::HEPTopTagger HTTagger(int i)  {return _HEPTopTagger[i];}
   const double n_small_fatjets(int i) {return _n_small_fatjets[i];}
 
+  void set_mode(int mode) {_mode = mode;}
+
   void set_max_subjet_mass(double x) {_subjet_mass = x;}
+  void set_mass_drop_threshold(double x) {_mass_drop_threshold = x;}
+  void set_minpt_subjet(double x) {_minpt_subjet = x;}
+  void set_minpt_tag(double x) {_minpt_tag = x;}
   void set_top_range(double top_range_min, double top_range_max) {_top_range[0] = top_range_min; _top_range[1] = top_range_max;}
   void set_f_W(double f_W) {_f_W = f_W;}
   void set_mass_ratio_cut(double mass_ratios_0, double mass_ratios_1, double mass_ratios_2) {_mass_ratios[0] = mass_ratios_0; _mass_ratios[1] = mass_ratios_1; _mass_ratios[2] = mass_ratios_2;}
@@ -56,10 +61,14 @@ private:
   const ClusterSequence * _cs;
   const PseudoJet *       _jet;
   double _mtmass, _mwmass;
+  double _mass_drop_threshold;
   double _subjet_mass;
+  double _minpt_subjet;
+  double _minpt_tag;
   map<int,external::HEPTopTagger> _HEPTopTagger;
   map<int,int> _n_small_fatjets;
   int _Rmin;
+  int _mode;
   double _mass_Rmin, _pt_Rmin;
   double _mass_mean, _mass_width;
   double _top_range[2];
diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
index 90953ed..9b3cd77 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
@@ -147,6 +147,9 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
    /// returns fW
    inline double fW() const {return _fW;}
 
+   /// returns Rmin
+   inline double R_min() const {return _Rmin;}
+
    /// returns if 2d-mass plane cuts were passed
    inline double mass_ratio_passed() const {return _mass_ratio_passed;}
     
@@ -155,9 +158,10 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
       double _top_mass;
       double _unfiltered_mass;
       double _pruned_mass;
-      double _fW;
+      double _fW;      
       int _mass_ratio_passed;
-
+      double _Rmin;
+      
       const JetDefinition::Recombiner  * W_rec;
  
       mutable PseudoJet rW_;
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
index b0ef169..cf00f19 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
@@ -36,8 +36,8 @@ MultiR_TopTagger::MultiR_TopTagger(double max_fatjet_R,
 				   double step_R,
 				   double multiR_threshold,
 				   bool use_dR_max_triplet,
-				   fastjet::ClusterSequence & cs, 
-				   fastjet::PseudoJet & jet, 
+				   const fastjet::ClusterSequence & cs, 
+				   const fastjet::PseudoJet & jet, 
 				   double mtmass, double mwmass
 				   ) : _cs(&cs),  _jet(&jet),
 				       _mtmass(mtmass),	_mwmass(mwmass), _max_fatjet_R(max_fatjet_R), _min_fatjet_R(min_fatjet_R), _step_R(step_R), _multiR_threshold(multiR_threshold), _use_dR_max_triplet(use_dR_max_triplet), _debug(false)
@@ -86,11 +86,15 @@ void MultiR_TopTagger::run_tagger() {
       htt.set_top_range(_top_range[0], _top_range[1]);
       htt.set_mass_ratio_cut(_mass_ratios[0], _mass_ratios[1], _mass_ratios[2]);
       htt.set_max_subjet_mass(_subjet_mass);
+      htt.set_minpt_subjet(_minpt_subjet);
+      htt.set_minpt_tag(_minpt_tag);
+      htt.set_mass_drop_threshold(_mass_drop_threshold);
       htt.set_nfilt(_n_filt);
       htt.set_Rfilt(_R_filt);
       htt.set_mass_ratio_range((1.-_f_W)*_mwmass/_mtmass, (1.+_f_W)*_mwmass/_mtmass); 
-      htt.set_mode(1);	
+      htt.set_mode(_mode); 
       
+
       htt.run_tagger();
      
       double deltatop = fabs(htt.top_candidate().m() - _mtmass);
@@ -100,18 +104,19 @@ void MultiR_TopTagger::run_tagger() {
       }
     } //End of loop over small_fatjets
     
-    if (_Rmin == 0 && R < maxR) {
-      double delta_m = fabs(_HEPTopTagger[maxR].top_candidate().m() - _HEPTopTagger[R].top_candidate().m());
-      if (delta_m > _multiR_threshold*_HEPTopTagger[maxR].top_candidate().m() || _HEPTopTagger[R].top_candidate().m() == 0) {
+    // Only check if we have not found Rmin yet
+    if (_Rmin == 0 && R < maxR) {                 
+      // If the new mass is OUTSIDE the window ..
+      if (_HEPTopTagger[R].top_candidate().m() < (1-_multiR_threshold)*_HEPTopTagger[maxR].top_candidate().m())
+	// .. set _Rmin to the previous mass 
 	_Rmin = R + stepR;
-      }
     }
     
     big_fatjets = small_fatjets;
     small_fatjets.clear();
-
   }//End of loop over R
 
+  // if we did not find Rmin in the loop, pick the last value
   if (_Rmin == 0 && _HEPTopTagger[maxR].top_candidate().m() > 0)
     _Rmin = minR;
 
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
index 1696e1a..27e4a76 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
@@ -46,19 +46,23 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
     throw Error("HEPTopTagger can only be applied on jets having an associated (and valid) ClusterSequence");
   }
 
-  external::HEPTopTagger tagger(jet);
-
-  // translate the massRatioWidth (which should be the half-width given in %) 
-  // to values useful for the A-shape cuts
-  double mw_over_mt = 80.4/172.3;
-  double ratio_min = mw_over_mt * (100.-massRatioWidth_)/100.;
-  double ratio_max = mw_over_mt * (100.+massRatioWidth_)/100.;
- 
-  
+  double m_W = 80.4;
+  double m_top = 172.3;
+
+  external::MultiR_TopTagger tagger(1.5,   // R_max
+				    0.5,   // R_min
+				    0.1,   // R_step
+				    0.2,   // Mass-drop threshold
+				    false, // use_dR_max_triplet
+				    *(jet.associated_cluster_sequence()),
+				    jet,
+				    m_top,
+				    m_W);
+   
   // Unclustering, Filtering & Subjet Settings
   tagger.set_max_subjet_mass(subjetMass_);
-  tagger.set_mass_drop_threshold(muCut_);
-  tagger.set_minpt_subjet(minSubjetPt_); 
+  tagger.set_mass_drop_threshold(muCut_); 
+  tagger.set_minpt_subjet(minSubjetPt_);
 
   // How to select among candidates
   tagger.set_mode(mode_);
@@ -67,23 +71,24 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   tagger.set_minpt_tag(minCandPt_); 
   tagger.set_top_range(minCandMass_, maxCandMass_); 
   tagger.set_mass_ratio_cut(minM23Cut_, minM13Cut_, maxM13Cut_);
-  tagger.set_mass_ratio_range(ratio_min, ratio_max);
+  tagger.set_f_W(massRatioWidth_/100.);
 
   tagger.run_tagger();
-
-  // Requires:
-  //   - top mass window
-  //   - mass ratio cuts
-  //   - minimal candidate pT
+  
+  // MultiR tagging requirements:
+  //   - found a valid R_min
+  //   - HTT top mass window
+  //   - HTT mass ratio cuts
+  //   - HTT minimal candidate pT
   // If this is not intended: use loose top mass and ratio windows
-  if (!tagger.is_tagged())
-    return PseudoJet();
+  if ( (tagger.Rmin_raw()==0) || (! tagger.cand_Rmin().is_tagged()))
+      return PseudoJet();
   
   // create the result and its structure
   const JetDefinition::Recombiner *rec
     = jet.associated_cluster_sequence()->jet_def().recombiner();
 
-  const vector<PseudoJet>& subjets = tagger.top_subjets();
+  const vector<PseudoJet>& subjets = tagger.cand_Rmin().top_subjets();
   assert(subjets.size() == 3);
 
   PseudoJet non_W = subjets[0];
@@ -94,13 +99,13 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   PseudoJet result = join<MultiRHEPTopTaggerStructure>( W1, W2, non_W, *rec);
   MultiRHEPTopTaggerStructure *s = (MultiRHEPTopTaggerStructure*) result.structure_non_const_ptr();
 
-  s->_top_mass = tagger.t().m();
-  s->_pruned_mass = tagger.pruned_mass();
-  s->_unfiltered_mass = tagger.unfiltered_mass();
-  s->_fW = tagger.fW();
-  s->_mass_ratio_passed = tagger.is_masscut_passed();
+  s->_top_mass = tagger.cand_Rmin().t().m();
+  s->_pruned_mass = tagger.cand_Rmin().pruned_mass();
+  s->_unfiltered_mass = tagger.cand_Rmin().unfiltered_mass();
+  s->_fW = tagger.cand_Rmin().fW();
+  s->_mass_ratio_passed = tagger.cand_Rmin().is_masscut_passed();
+  s->_Rmin = tagger.Rmin();
 
-  // Removed selectors as all cuts are applied ion HTT
   return result;
 }
 
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
index 363f1ef..f841b69 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -76,19 +76,36 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
   // Create the tagger-wrapper
   produces<HTTTopJetTagInfoCollection>();
 
-  fjHEPTopTagger_ = std::auto_ptr<fastjet::HEPTopTagger>(new fastjet::HEPTopTagger(minSubjetPt_, 
-										   minCandPt_,
-										   subjetMass_, 	    
-										   muCut_, 		    
-										   mode_, 		    
-										   minCandMass_, 	    
-										   maxCandMass_, 	    
-										   massRatioWidth_, 	    
-										   minM23Cut_, 	    
-										   minM13Cut_, 	    
-										   maxM13Cut_)); 
+  // Signal to the VirtualJetProducer that we have to add HTT information
   fromHTTTopJetProducer_ = 1;
 
+  if (multiR_){
+    fjMultiRHEPTopTagger_ = std::auto_ptr<fastjet::MultiRHEPTopTagger>(new fastjet::MultiRHEPTopTagger(minSubjetPt_, 
+												       minCandPt_,
+												       subjetMass_, 	    
+												       muCut_, 		    
+												       mode_, 		    
+												       minCandMass_, 	    
+												       maxCandMass_, 	    
+												       massRatioWidth_, 	    
+												       minM23Cut_, 	    
+												       minM13Cut_, 	    
+												       maxM13Cut_)); 
+  }
+  else{
+    fjHEPTopTagger_ = std::auto_ptr<fastjet::HEPTopTagger>(new fastjet::HEPTopTagger(minSubjetPt_, 
+										     minCandPt_,
+										     subjetMass_, 	    
+										     muCut_, 		    
+										     mode_, 		    
+										     minCandMass_, 	    
+										     maxCandMass_, 	    
+										     massRatioWidth_, 	    
+										     minM23Cut_, 	    
+										     minM13Cut_, 	    
+										     maxM13Cut_)); 
+  }
+
 }
 
 		
@@ -125,6 +142,7 @@ void HTTTopJetProducer::runAlgorithm( edm::Event& iEvent, const edm::EventSetup&
   }
 
   fastjet::HEPTopTagger & HEPTagger = *fjHEPTopTagger_;
+  fastjet::MultiRHEPTopTagger & MultiRHEPTagger = *fjMultiRHEPTopTagger_;
 
   vector<fastjet::PseudoJet>::iterator jetIt = centralJets.begin(), centralJetsEnd = centralJets.end();
   if ( verbose_ )cout<<"Loop over jets"<<endl;
@@ -133,8 +151,12 @@ void HTTTopJetProducer::runAlgorithm( edm::Event& iEvent, const edm::EventSetup&
     if (verbose_) cout << "CMS FJ jet pt: " << (*jetIt).perp() << endl;
     
     fastjet::PseudoJet taggedJet;
-    taggedJet = HEPTagger.result(*jetIt);
-    
+
+    if (multiR_)
+      taggedJet = MultiRHEPTagger.result(*jetIt);
+    else
+      taggedJet = HEPTagger.result(*jetIt);
+
     if (taggedJet != 0){
       fjJets_.push_back(taggedJet);           
     }
@@ -163,21 +185,38 @@ void HTTTopJetProducer::addHTTTopJetTagInfoCollection( edm::Event& iEvent,
     edm::Ref<reco::BasicJetCollection> ref(oh, ij);  
     edm::RefToBase<reco::Jet> rtb(ref);  
     
-    fastjet::HEPTopTaggerStructure *s = (fastjet::HEPTopTaggerStructure*) fjJets_[ij].structure_non_const_ptr();
-
-    properties.topMass          = s->top_mass();
-    properties.unfilteredMass	= s->unfiltered_mass();
-    properties.prunedMass	= s->pruned_mass();
-    properties.fW		= s->fW();
-    properties.massRatioPassed  = s->mass_ratio_passed();
-
-    // Only needed for MultiR tagger
-    properties.isMultiR	        = 0;
-    properties.Rmin	        = -1.;
-    properties.RminExpected     = -1.;
-    
-    tagInfo.insert(rtb, properties );
-    tagInfos->push_back( tagInfo );
+    if (multiR_){
+      fastjet::MultiRHEPTopTaggerStructure *s = (fastjet::MultiRHEPTopTaggerStructure*) fjJets_[ij].structure_non_const_ptr();
+      
+      properties.topMass         = s->top_mass();
+      properties.unfilteredMass	 = s->unfiltered_mass();
+      properties.prunedMass	 = s->pruned_mass();
+      properties.fW		 = s->fW();
+      properties.massRatioPassed = s->mass_ratio_passed();     
+      properties.isMultiR	 = 1;
+      properties.Rmin	         = s->R_min();    
+      properties.RminExpected    = 999.;
+      
+      tagInfo.insert(rtb, properties );
+      tagInfos->push_back( tagInfo );
+    }
+    else{      
+      fastjet::HEPTopTaggerStructure *s = (fastjet::HEPTopTaggerStructure*) fjJets_[ij].structure_non_const_ptr();
+      
+      properties.topMass         = s->top_mass();
+      properties.unfilteredMass	 = s->unfiltered_mass();
+      properties.prunedMass	 = s->pruned_mass();
+      properties.fW		 = s->fW();
+      properties.massRatioPassed = s->mass_ratio_passed();
+      
+      // Only needed for MultiR tagger
+      properties.isMultiR	        = 0;
+      properties.Rmin	        = -1.;
+      properties.RminExpected     = -1.;
+      
+      tagInfo.insert(rtb, properties );
+      tagInfos->push_back( tagInfo );
+    }
   }  
 
   iEvent.put( tagInfos );
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
index 6326a98..e0f9968 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
@@ -63,8 +63,8 @@
 
 #include "RecoJets/JetProducers/plugins/FastjetJetProducer.h"
 
-
 #include "RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h"
+#include "RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h"
 
 #include "fastjet/SISConePlugin.hh"
 
@@ -89,7 +89,8 @@ namespace cms
 
 
   private:
-    std::auto_ptr<fastjet::HEPTopTagger>     fjHEPTopTagger_;
+    std::auto_ptr<fastjet::HEPTopTagger>        fjHEPTopTagger_;
+    std::auto_ptr<fastjet::MultiRHEPTopTagger>  fjMultiRHEPTopTagger_;
 
     // Below are all configurable options. 
     // Parenthesis indicates if this is enforced by the tagger itself or by the producer
-- 
1.8.3.1


From 2e9130dcd6c6790e69172df48bcb285a9f85c2c7 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Thu, 16 Oct 2014 15:36:31 +0200
Subject: [PATCH 08/22] Added chaning of Rmin and Rmax for MultiR tagger

---
 .../JetAlgorithms/interface/HEPTopTaggerWrapper.h  |  6 ------
 .../interface/MultiRHEPTopTaggerWrapper.h          | 24 ++++++++++++----------
 .../JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc |  8 +++++---
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc | 13 +++++++++++-
 RecoJets/JetProducers/plugins/HTTTopJetProducer.h  |  3 +++
 5 files changed, 33 insertions(+), 21 deletions(-)

diff --git a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
index 0238882..f496bd7 100644
--- a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
@@ -114,7 +114,6 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
    /// ctor with pieces initialisation
    HEPTopTaggerStructure(const std::vector<PseudoJet>& pieces_in,
                   const JetDefinition::Recombiner *recombiner = 0) : CompositeJetStructure(pieces_in, recombiner),
-    _cos_theta_w(0.0),
     _top_mass(0.0),
     _unfiltered_mass(0.0),
     _pruned_mass(0.0),
@@ -149,9 +148,6 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
      return _pieces[2];
    }
  
-   /// returns the W helicity angl
-   inline double cos_theta_W() const {return _cos_theta_w;}
-
    /// returns the candidate mass
    inline double top_mass() const {return _top_mass;}
 
@@ -168,7 +164,6 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
    inline double mass_ratio_passed() const {return _mass_ratio_passed;}
     
  protected:
-      double _cos_theta_w; ///< the W helicity angle
       double _top_mass;
       double _unfiltered_mass;
       double _pruned_mass;
@@ -188,7 +183,6 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
 // description of the tagger
 inline std::string HEPTopTagger::description() const{ 
 
-  // TODO: FIXME!!!
   std::ostringstream oss;
   oss << "HEPTopTagger with: "
       << "minSubjetPt = " << minSubjetPt_ 
diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
index 9b3cd77..5704421 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
@@ -40,7 +40,9 @@ public:
 		     double massRatioWidth, 
 		     double minM23Cut, 
 		     double minM13Cut, 
-		     double maxM13Cut) : minSubjetPt_(minSubjetPt),
+		     double maxM13Cut,
+		     double R_max,
+		     double R_min) : minSubjetPt_(minSubjetPt),
     minCandPt_(minCandPt),
     subjetMass_(subjetMass),
     muCut_(muCut),
@@ -50,7 +52,9 @@ public:
     massRatioWidth_(massRatioWidth),
     minM23Cut_(minM23Cut),
     minM13Cut_(minM13Cut),
-    maxM13Cut_(maxM13Cut)   
+    maxM13Cut_(maxM13Cut),
+    R_max_(R_max),
+    R_min_(R_min)
   {}
 
   /// returns a textual description of the tagger
@@ -65,7 +69,7 @@ public:
   // the type of the associated structure
   typedef MultiRHEPTopTaggerStructure StructureType;
 
-private:
+private: 
     double minSubjetPt_; // Minimal pT for subjets [GeV]
     double minCandPt_;   // Minimal pT to return a candidate [GeV]
  
@@ -89,6 +93,9 @@ private:
     double minM23Cut_; // minimal value of m23/m123
     double minM13Cut_; // minimal value of atan(m13/m12)
     double maxM13Cut_; // maximal value of atan(m13/m12)
+
+    double R_max_; // Maximal fatjet size to consider
+    double R_min_; // Minimal fatjet size to consider
 };
 
 
@@ -97,7 +104,6 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
    /// ctor with pieces initialisation
    MultiRHEPTopTaggerStructure(const std::vector<PseudoJet>& pieces_in,
                   const JetDefinition::Recombiner *recombiner = 0) : CompositeJetStructure(pieces_in, recombiner),
-    _cos_theta_w(0.0),
     _top_mass(0.0),
     _unfiltered_mass(0.0),
     _pruned_mass(0.0),
@@ -132,9 +138,6 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
      return _pieces[2];
    }
  
-   /// returns the W helicity angl
-   inline double cos_theta_W() const {return _cos_theta_w;}
-
    /// returns the candidate mass
    inline double top_mass() const {return _top_mass;}
 
@@ -154,7 +157,6 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
    inline double mass_ratio_passed() const {return _mass_ratio_passed;}
     
  protected:
-      double _cos_theta_w; ///< the W helicity angle
       double _top_mass;
       double _unfiltered_mass;
       double _pruned_mass;
@@ -176,7 +178,6 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
 // description of the tagger
 inline std::string MultiRHEPTopTagger::description() const{ 
 
-  // TODO: FIXME!!!
   std::ostringstream oss;
   oss << "MultiRHEPTopTagger with: "
       << "minSubjetPt = " << minSubjetPt_ 
@@ -188,8 +189,9 @@ inline std::string MultiRHEPTopTagger::description() const{
       << "maxCandMass = " << maxCandMass_ 
       << "massRatioWidth = " << massRatioWidth_ 
       << "minM23Cut = " << minM23Cut_ 
-      << "minM13Cut = " << minM13Cut_ 
-      << "maxM13Cut = " << maxM13Cut_ << std::endl;
+      << "minM13Cut = " << minM13Cut_
+      << "Rmax = " << R_max_ 
+      << "Rmin = " << R_min_ << std::endl;
   return oss.str();
 }
 
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
index 27e4a76..39b9f0c 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
@@ -49,9 +49,9 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   double m_W = 80.4;
   double m_top = 172.3;
 
-  external::MultiR_TopTagger tagger(1.5,   // R_max
-				    0.5,   // R_min
-				    0.1,   // R_step
+  external::MultiR_TopTagger tagger(R_max_,   // R_max
+				    R_min_,   // R_min
+				    0.1,   // R_step (using a stepsize smaller than 0.1 would currently not work)
 				    0.2,   // Mass-drop threshold
 				    false, // use_dR_max_triplet
 				    *(jet.associated_cluster_sequence()),
@@ -105,6 +105,8 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   s->_fW = tagger.cand_Rmin().fW();
   s->_mass_ratio_passed = tagger.cand_Rmin().is_masscut_passed();
   s->_Rmin = tagger.Rmin();
+  // TODO: Add Rmin(expected)
+  
 
   return result;
 }
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
index f841b69..56e3334 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -24,6 +24,8 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
        minM23Cut_(0.35),
        minM13Cut_(0.2),
        maxM13Cut_(1.3),
+       maxR_(1.5),
+       minR_(0.5),
        verbose_(false )
 {
   
@@ -69,6 +71,13 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
   
   if ( conf.exists("maxM13Cut") )
     maxM13Cut_ = conf.getParameter<double>("maxM13Cut");
+
+  if ( conf.exists("maxR") )
+    maxR_ = conf.getParameter<double>("maxR");
+
+  if ( conf.exists("minR") )
+    minR_ = conf.getParameter<double>("minR");
+
   
   if ( conf.exists("verbose") )
     verbose_ = conf.getParameter<bool>("verbose");
@@ -90,7 +99,9 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
 												       massRatioWidth_, 	    
 												       minM23Cut_, 	    
 												       minM13Cut_, 	    
-												       maxM13Cut_)); 
+												       maxM13Cut_,
+												       maxR_,
+												       minR_)); 
   }
   else{
     fjHEPTopTagger_ = std::auto_ptr<fastjet::HEPTopTagger>(new fastjet::HEPTopTagger(minSubjetPt_, 
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
index e0f9968..d6a7a90 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
@@ -123,6 +123,9 @@ namespace cms
     double minM23Cut_; // minimal value of m23/m123 (tagger)
     double minM13Cut_; // minimal value of atan(m13/m12) (tagger)
     double maxM13Cut_; // maximal value of atan(m13/m12) (tagger)
+
+    double maxR_; // maximal fatjet size for MultiR tagger (tagger)
+    double minR_; // minimal fatjet size for MultiR tagger (tagger)
         
     bool verbose_;
 
-- 
1.8.3.1


From 0b5b3a1da9d6d99719d51abaa1c60bf4874c10d0 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Mon, 20 Oct 2014 13:34:37 +0200
Subject: [PATCH 09/22] Made filtR and filtN fully steerable

---
 RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h     |  9 +++++++++
 .../JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h    |  9 +++++++++
 RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc          |  2 ++
 RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc    |  2 ++
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc         | 14 +++++++++++++-
 RecoJets/JetProducers/plugins/HTTTopJetProducer.h          |  3 +++
 6 files changed, 38 insertions(+), 1 deletion(-)

diff --git a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
index f496bd7..d324827 100644
--- a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
@@ -51,6 +51,8 @@ public:
 	       double minCandPt, 
 	       double subjetMass, 
 	       double muCut, 
+	       double filtR,
+	       int filtN,
 	       int mode, 
 	       double minCandMass, 
 	       double maxCandMass, 
@@ -61,6 +63,8 @@ public:
     minCandPt_(minCandPt),
     subjetMass_(subjetMass),
     muCut_(muCut),
+    filtR_(filtR),
+    filtN_(filtN),
     mode_(mode),
     minCandMass_(minCandMass),
     maxCandMass_(maxCandMass),
@@ -89,6 +93,9 @@ private:
     double subjetMass_; // Mass above which subjets are further unclustered
     double muCut_; // Mass drop threshold
     
+    double filtR_; // maximal filtering radius
+    int filtN_; // number of filtered subjets to use
+
     // HEPTopTagger Mode
     // 0: do 2d-plane, return candidate with delta m_top minimal
     // 1: return candidate with delta m_top minimal IF passes 2d plane
@@ -189,6 +196,8 @@ inline std::string HEPTopTagger::description() const{
       << "minCandPt = " << minCandPt_ 
       << "subjetMass = " << subjetMass_ 
       << "muCut = " << muCut_ 
+      << "filtR = " << filtR_ 
+      << "filtN = " << filtN_     
       << "mode = " << mode_ 
       << "minCandMass = " << minCandMass_ 
       << "maxCandMass = " << maxCandMass_ 
diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
index 5704421..6de8fb1 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
@@ -34,6 +34,8 @@ public:
 		     double minCandPt, 
 		     double subjetMass, 
 		     double muCut, 
+		     double filtR,
+		     int filtN,
 		     int mode, 
 		     double minCandMass, 
 		     double maxCandMass, 
@@ -46,6 +48,8 @@ public:
     minCandPt_(minCandPt),
     subjetMass_(subjetMass),
     muCut_(muCut),
+    filtR_(filtR),
+    filtN_(filtN),
     mode_(mode),
     minCandMass_(minCandMass),
     maxCandMass_(maxCandMass),
@@ -76,6 +80,9 @@ private:
     double subjetMass_; // Mass above which subjets are further unclustered
     double muCut_; // Mass drop threshold
     
+    double filtR_; // maximal filtering radius
+    int filtN_; // number of filtered subjets to use
+    
     // HEPTopTagger Mode
     // 0: do 2d-plane, return candidate with delta m_top minimal
     // 1: return candidate with delta m_top minimal IF passes 2d plane
@@ -184,6 +191,8 @@ inline std::string MultiRHEPTopTagger::description() const{
       << "minCandPt = " << minCandPt_ 
       << "subjetMass = " << subjetMass_ 
       << "muCut = " << muCut_ 
+      << "filtR = " << filtR_ 
+      << "filtN = " << filtN_     
       << "mode = " << mode_ 
       << "minCandMass = " << minCandMass_ 
       << "maxCandMass = " << maxCandMass_ 
diff --git a/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
index 0c4823c..a82b037 100644
--- a/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
@@ -60,6 +60,8 @@ PseudoJet HEPTopTagger::result(const PseudoJet & jet) const{
   // Unclustering, Filtering & Subjet Settings
   tagger.set_max_subjet_mass(subjetMass_);
   tagger.set_mass_drop_threshold(muCut_);
+  tagger.set_Rfilt(filtR_);
+  tagger.set_nfilt(filtN_);
   tagger.set_minpt_subjet(minSubjetPt_); 
 
   // How to select among candidates
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
index 39b9f0c..a6b8433 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
@@ -62,6 +62,8 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   // Unclustering, Filtering & Subjet Settings
   tagger.set_max_subjet_mass(subjetMass_);
   tagger.set_mass_drop_threshold(muCut_); 
+  tagger.set_Rfilt(filtR_);
+  tagger.set_nfilt(filtN_);
   tagger.set_minpt_subjet(minSubjetPt_);
 
   // How to select among candidates
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
index 56e3334..fb7db32 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -17,6 +17,8 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
        maxFatjetAbsEta_(2.5),
        subjetMass_(30.),
        muCut_(0.8),
+       filtR_(0.3),
+       filtN_(5),       
        mode_(0),
        minCandMass_(150.),
        maxCandMass_(200.),
@@ -50,6 +52,12 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
   
   if ( conf.exists("muCut") )
     muCut_ = conf.getParameter<double>("muCut");
+
+  if ( conf.exists("filtR") )
+    filtR_ = conf.getParameter<double>("filtR");
+
+  if ( conf.exists("filtN") )
+    filtN_ = conf.getParameter<int>("filtN");
   
   if ( conf.exists("mode") )
     mode_ = conf.getParameter<int>("mode");
@@ -92,7 +100,9 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
     fjMultiRHEPTopTagger_ = std::auto_ptr<fastjet::MultiRHEPTopTagger>(new fastjet::MultiRHEPTopTagger(minSubjetPt_, 
 												       minCandPt_,
 												       subjetMass_, 	    
-												       muCut_, 		    
+												       muCut_, 	
+												       filtR_,
+												       filtN_,
 												       mode_, 		    
 												       minCandMass_, 	    
 												       maxCandMass_, 	    
@@ -108,6 +118,8 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
 										     minCandPt_,
 										     subjetMass_, 	    
 										     muCut_, 		    
+										     filtR_,
+										     filtN_,
 										     mode_, 		    
 										     minCandMass_, 	    
 										     maxCandMass_, 	    
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
index d6a7a90..e3cc5bc 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
@@ -105,6 +105,9 @@ namespace cms
 
     double subjetMass_; // Mass above which subjets are further unclustered (tagger)
     double muCut_; // Mass drop threshold (tagger)
+
+    double filtR_; // maximal filtering radius
+    int filtN_; // number of filtered subjets to use
     
     // HEPTopTagger Mode (tagger):
     // 0: do 2d-plane, return candidate with delta m_top minimal
-- 
1.8.3.1


From 3c46d23a009906f06b1dc86dbe51982f33a37cfc Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Mon, 20 Oct 2014 14:05:00 +0200
Subject: [PATCH 10/22] Switched to pt-sorting between different MultiR cands
 (59fa31e48f0b479f6a563597ca445a29c8db6a74)

---
 RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
index cf00f19..2e059c3 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
@@ -79,7 +79,9 @@ void MultiR_TopTagger::run_tagger() {
     if (_debug) {cout << "R = " << R << " -> n_small_fatjets = " << small_fatjets.size();}
     
     _n_small_fatjets[R] = small_fatjets.size();
-    double dummy = 1000000000000.0;
+
+    // We are sorting by pt - so start with a negative dummy
+    double dummy = -99999;
 
     for (unsigned i = 0; i < small_fatjets.size(); i++) {
       external::HEPTopTagger htt(small_fatjets[i], _mtmass, _mwmass);
@@ -94,12 +96,10 @@ void MultiR_TopTagger::run_tagger() {
       htt.set_mass_ratio_range((1.-_f_W)*_mwmass/_mtmass, (1.+_f_W)*_mwmass/_mtmass); 
       htt.set_mode(_mode); 
       
-
       htt.run_tagger();
      
-      double deltatop = fabs(htt.top_candidate().m() - _mtmass);
-      if (deltatop < dummy) {
-	dummy = deltatop;
+      if (htt.top_candidate().perp() > dummy) {
+	dummy = htt.top_candidate().perp();
 	_HEPTopTagger[R] = htt;
       }
     } //End of loop over small_fatjets
-- 
1.8.3.1


From 446dd8f4fc7159046bcbef96c5accec5069fe5be Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Mon, 27 Oct 2014 13:19:19 +0100
Subject: [PATCH 11/22] Update with few small changes to HTT interface. Now at
 e21bcdc45c55050d1bfdabe4ca8d664062887f6f

---
 RecoJets/JetAlgorithms/interface/HEPTopTagger.h    |  4 +--
 .../JetAlgorithms/interface/MultiRHEPTopTagger.h   | 10 +++++--
 RecoJets/JetAlgorithms/src/HEPTopTagger.cc         | 34 +++++++++++-----------
 RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc   |  8 ++++-
 4 files changed, 33 insertions(+), 23 deletions(-)

diff --git a/RecoJets/JetAlgorithms/interface/HEPTopTagger.h b/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
index c66a79b..00a9ec6 100644
--- a/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
+++ b/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
@@ -84,7 +84,7 @@ public:
   void set_filtering_jetalgorithm(JetAlgorithm jet_algorithm) {_jet_algorithm_filter = jet_algorithm;}
   void set_reclustering_jetalgorithm(JetAlgorithm jet_algorithm) {_jet_algorithm_recluster = jet_algorithm;}
   void set_pruner_cuts(double zcut, double rcut_factor) {_zcut = zcut; _rcut_factor = rcut_factor;}
-  void set_mode(int mode) {_mode = mode;}
+  void set_mode(int mode) {_mode = Mode(mode);}
   void set_debug(bool debug) {_debug = debug;}
   void set_minpt_tag(double x) {_minpt_tag = x;}
   void set_minpt_subjet(double x) {_minpt_subjet = x;}
@@ -104,7 +104,7 @@ private:
   JetAlgorithm _jet_algorithm_recluster;
   double _zcut;
   double _rcut_factor;
-  int _mode;
+  Mode _mode;
   double _minpt_tag;
   double _minpt_subjet;
   bool _debug;
diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
index 9cb4475..14432d3 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
@@ -33,14 +33,16 @@ public:
   void run_tagger();
 
   // Return the candidate (and some properties) at R=R_min
-  external::HEPTopTagger cand_Rmin(){return _HEPTopTagger[_Rmin];}
+  HEPTopTagger cand_Rmin(){return _HEPTopTagger[_Rmin];}
   const int & Rmin_raw() const {return _Rmin;}
   const double Rmin() const {return _Rmin/10.;}
   const double & mass_Rmin() const {return _mass_Rmin;}
   const double & pt_Rmin() const {return _pt_Rmin;}
   
+  double R_min_exp(double x) {return _r_min_exp_function(x);}
+
   // Access to all candidates and number-of-small-fatjets
-  external::HEPTopTagger HTTagger(int i)  {return _HEPTopTagger[i];}
+  HEPTopTagger HTTagger(int i)  {return _HEPTopTagger[i];}
   const double n_small_fatjets(int i) {return _n_small_fatjets[i];}
 
   void set_mode(int mode) {_mode = mode;}
@@ -55,6 +57,7 @@ public:
   void set_nfilt(unsigned nfilt) {_n_filt = nfilt;}
   void set_Rfilt(double Rfilt) {_R_filt = Rfilt;}
   void set_debug(bool debug) {_debug = debug;}
+  void set_r_min_exp_function(double (*f)(double)) {_r_min_exp_function = f;}
  
 
 private:
@@ -63,8 +66,8 @@ private:
   double _mtmass, _mwmass;
   double _mass_drop_threshold;
   double _subjet_mass;
-  double _minpt_subjet;
   double _minpt_tag;
+  double _minpt_subjet;
   map<int,external::HEPTopTagger> _HEPTopTagger;
   map<int,int> _n_small_fatjets;
   int _Rmin;
@@ -79,6 +82,7 @@ private:
   double _max_fatjet_R, _min_fatjet_R, _step_R, _multiR_threshold;
   bool _use_dR_max_triplet;
   bool _debug;
+  double (*_r_min_exp_function)(double);
 
   void UnclusterFatjets(const vector<fastjet::PseudoJet> & big_fatjets, vector<fastjet::PseudoJet> & small_fatjets, const ClusterSequence & cs, const double small_radius);
 
diff --git a/RecoJets/JetAlgorithms/src/HEPTopTagger.cc b/RecoJets/JetAlgorithms/src/HEPTopTagger.cc
index 2c230bc..57932e5 100644
--- a/RecoJets/JetAlgorithms/src/HEPTopTagger.cc
+++ b/RecoJets/JetAlgorithms/src/HEPTopTagger.cc
@@ -132,7 +132,7 @@ HEPTopTagger::HEPTopTagger(fastjet::PseudoJet jet) :
   _mtmin(150.), _mtmax(200.), _rmin(0.85*80.4/172.3), _rmax(1.15*80.4/172.3), 
   _m23cut(0.35), _m13cutmin(0.2), _m13cutmax(1.3), 
   _nfilt(5), _Rfilt(0.3), _Rprun(1.5), _jet_algorithm_filter(fastjet::cambridge_algorithm), _jet_algorithm_recluster(fastjet::cambridge_algorithm), _zcut(0.1),
-  _rcut_factor(0.5), _mode(0), _minpt_tag(200.), _minpt_subjet(0.), _debug(false), _fat(jet)
+  _rcut_factor(0.5), _mode(Mode(0)), _minpt_tag(200.), _minpt_subjet(0.), _debug(false), _fat(jet)
 {}
 
 HEPTopTagger::HEPTopTagger(fastjet::PseudoJet jet, 
@@ -143,17 +143,17 @@ HEPTopTagger::HEPTopTagger(fastjet::PseudoJet jet,
   _mtmin(150.), _mtmax(200.), _rmin(0.85*mwmass/mtmass), _rmax(1.15*mwmass/mtmass), 
   _m23cut(0.35), _m13cutmin(0.2), _m13cutmax(1.3), 
   _nfilt(5), _Rfilt(0.3), _Rprun(1.5), _jet_algorithm_filter(fastjet::cambridge_algorithm), _jet_algorithm_recluster(fastjet::cambridge_algorithm), _zcut(0.1),
-  _rcut_factor(0.5), _mode(0), _minpt_tag(200.), _debug(false), _fat(jet)
+  _rcut_factor(0.5), _mode(Mode(0)), _minpt_tag(200.), _minpt_subjet(0.), _debug(false), _fat(jet)
 {}
 
 void HEPTopTagger::run_tagger() {
   print_banner();
 
-  if ((_mode != Mode::EARLY_MASSRATIO_SORT_MASS) 
-      && (_mode != Mode::LATE_MASSRATIO_SORT_MASS) 
-      && (_mode != Mode::EARLY_MASSRATIO_SORT_MODDJADE)
-      && (_mode != Mode::LATE_MASSRATIO_SORT_MODDJADE)
-      && (_mode != Mode::TWO_STEP_FILTER) ) {
+  if ((_mode != EARLY_MASSRATIO_SORT_MASS) 
+      && (_mode != LATE_MASSRATIO_SORT_MASS) 
+      && (_mode != EARLY_MASSRATIO_SORT_MODDJADE)
+      && (_mode != LATE_MASSRATIO_SORT_MODDJADE)
+      && (_mode != TWO_STEP_FILTER) ) {
     std::cout << "ERROR: UNKNOWN MODE" << std::endl;
     return;
   }
@@ -193,11 +193,11 @@ void HEPTopTagger::run_tagger() {
 	// two-step filtering 
 	// This means that we only look at the triplet formed by the
 	// three leading-in-pT subjets-after-unclustering.
-	if((_mode==Mode::TWO_STEP_FILTER) && rr>0)
+	if((_mode==TWO_STEP_FILTER) && rr>0)
 	  continue;
-	if((_mode==Mode::TWO_STEP_FILTER) && ll>1)
+	if((_mode==TWO_STEP_FILTER) && ll>1)
 	  continue;
-	if((_mode==Mode::TWO_STEP_FILTER) && kk>2)
+	if((_mode==TWO_STEP_FILTER) && kk>2)
 	  continue;
 
       	//pick triple
@@ -233,8 +233,8 @@ void HEPTopTagger::run_tagger() {
 	  continue;
 
 	// Modes with early 2d-massplane cuts
-	if (_mode == Mode::EARLY_MASSRATIO_SORT_MASS      && !check_mass_criteria(top_subs)) {continue;}
-	if (_mode == Mode::EARLY_MASSRATIO_SORT_MODDJADE  && !check_mass_criteria(top_subs)) {continue;}
+	if (_mode == EARLY_MASSRATIO_SORT_MASS      && !check_mass_criteria(top_subs)) {continue;}
+	if (_mode == EARLY_MASSRATIO_SORT_MODDJADE  && !check_mass_criteria(top_subs)) {continue;}
 
 	//is this candidate better than the other? -> update
 	double deltatop = fabs(topcandidate.m() - _mtmass);
@@ -244,21 +244,21 @@ void HEPTopTagger::run_tagger() {
 	bool better = false;
 
 	// Modes 0 and 1 sort by top mass
-	if ( (_mode == Mode::EARLY_MASSRATIO_SORT_MASS) 
-	     || (_mode == Mode::LATE_MASSRATIO_SORT_MASS)) {
+	if ( (_mode == EARLY_MASSRATIO_SORT_MASS) 
+	     || (_mode == LATE_MASSRATIO_SORT_MASS)) {
 	  if (deltatop < _delta_top) 
 	    better = true;
 	}
 	// Modes 2 and 3 sort by modified jade distance
-	else if ( (_mode == Mode::EARLY_MASSRATIO_SORT_MODDJADE) 
-		  || (_mode == Mode::LATE_MASSRATIO_SORT_MODDJADE)) {
+	else if ( (_mode == EARLY_MASSRATIO_SORT_MODDJADE) 
+		  || (_mode == LATE_MASSRATIO_SORT_MODDJADE)) {
 	  if (djsum > _djsum) 
 	    better = true;
 	}
 	// Mode 4 is the two-step filtering. No sorting necessary as
 	// we just look at the triplet of highest pT objects after
 	// unclustering
-	else if (_mode == Mode::TWO_STEP_FILTER) {
+	else if (_mode == TWO_STEP_FILTER) {
 	  better = true;
 	} 
 	else {
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
index 2e059c3..552d4f2 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
@@ -40,7 +40,9 @@ MultiR_TopTagger::MultiR_TopTagger(double max_fatjet_R,
 				   const fastjet::PseudoJet & jet, 
 				   double mtmass, double mwmass
 				   ) : _cs(&cs),  _jet(&jet),
-				       _mtmass(mtmass),	_mwmass(mwmass), _max_fatjet_R(max_fatjet_R), _min_fatjet_R(min_fatjet_R), _step_R(step_R), _multiR_threshold(multiR_threshold), _use_dR_max_triplet(use_dR_max_triplet), _debug(false)
+				       _mtmass(mtmass),	_mwmass(mwmass), _mass_drop_threshold(0.8), _minpt_tag(200.), _minpt_subjet(0.), _mode(1), 
+				       _max_fatjet_R(max_fatjet_R), _min_fatjet_R(min_fatjet_R), _step_R(step_R), _multiR_threshold(multiR_threshold), 
+				       _use_dR_max_triplet(use_dR_max_triplet), _debug(false)
 {}
 
 void MultiR_TopTagger::run_tagger() {
@@ -120,6 +122,10 @@ void MultiR_TopTagger::run_tagger() {
   if (_Rmin == 0 && _HEPTopTagger[maxR].top_candidate().m() > 0)
     _Rmin = minR;
 
+  //for the case that there is no tag at all (< 3 hard substructures)
+  if (_Rmin == 0 && _HEPTopTagger[maxR].top_candidate().m() == 0)
+    _Rmin = maxR;
+
   _mass_Rmin = _HEPTopTagger[_Rmin].top_candidate().m();
   _pt_Rmin = _HEPTopTagger[_Rmin].top_candidate().perp();
  
-- 
1.8.3.1


From 30a65b11615ebbe3e3b36595ef981741dd2b4839 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Tue, 28 Oct 2014 17:57:59 +0100
Subject: [PATCH 12/22] First preps for Rmin exptected from
 56ca98d274b068876b0a7d9f7224789dbc95a65b

---
 RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h | 10 ++++++++++
 RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc      | 14 +++++++++++---
 2 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
index 14432d3..6c38707 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
@@ -39,6 +39,11 @@ public:
   const double & mass_Rmin() const {return _mass_Rmin;}
   const double & pt_Rmin() const {return _pt_Rmin;}
   
+  // Return pT for usage in determining R_min expected filtered pT of
+  // the initial fatjet, but with different filtering settings then
+  // used for the HTT
+  const double & pt_for_exp() const {return _pt_for_exp;}
+  
   double R_min_exp(double x) {return _r_min_exp_function(x);}
 
   // Access to all candidates and number-of-small-fatjets
@@ -56,6 +61,8 @@ public:
   void set_mass_ratio_cut(double mass_ratios_0, double mass_ratios_1, double mass_ratios_2) {_mass_ratios[0] = mass_ratios_0; _mass_ratios[1] = mass_ratios_1; _mass_ratios[2] = mass_ratios_2;}
   void set_nfilt(unsigned nfilt) {_n_filt = nfilt;}
   void set_Rfilt(double Rfilt) {_R_filt = Rfilt;}
+  void set_nfilt_for_exp_Rmin(unsigned nfilt_exp) {_n_filt_exp = nfilt_exp;}
+  void set_Rfilt_for_exp_Rmin(double Rfilt_exp) {_R_filt_exp = Rfilt_exp;}
   void set_debug(bool debug) {_debug = debug;}
   void set_r_min_exp_function(double (*f)(double)) {_r_min_exp_function = f;}
  
@@ -68,6 +75,7 @@ private:
   double _subjet_mass;
   double _minpt_tag;
   double _minpt_subjet;
+  double _pt_for_exp;
   map<int,external::HEPTopTagger> _HEPTopTagger;
   map<int,int> _n_small_fatjets;
   int _Rmin;
@@ -77,6 +85,8 @@ private:
   double _top_range[2];
   unsigned _n_filt;
   double _R_filt;
+  unsigned _n_filt_exp;
+  double _R_filt_exp;
   double _f_W;
   double _mass_ratios[3];
   double _max_fatjet_R, _min_fatjet_R, _step_R, _multiR_threshold;
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
index 552d4f2..517894b 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
@@ -40,7 +40,7 @@ MultiR_TopTagger::MultiR_TopTagger(double max_fatjet_R,
 				   const fastjet::PseudoJet & jet, 
 				   double mtmass, double mwmass
 				   ) : _cs(&cs),  _jet(&jet),
-				       _mtmass(mtmass),	_mwmass(mwmass), _mass_drop_threshold(0.8), _minpt_tag(200.), _minpt_subjet(0.), _mode(1), 
+				       _mtmass(mtmass),	_mwmass(mwmass), _mass_drop_threshold(0.8), _minpt_tag(200.), _minpt_subjet(0.), _mode(1), _n_filt_exp(10), _R_filt_exp(0.2),
 				       _max_fatjet_R(max_fatjet_R), _min_fatjet_R(min_fatjet_R), _step_R(step_R), _multiR_threshold(multiR_threshold), 
 				       _use_dR_max_triplet(use_dR_max_triplet), _debug(false)
 {}
@@ -50,7 +50,15 @@ void MultiR_TopTagger::run_tagger() {
     cout << "============================="  << endl 
 	 << "new MultiR" << endl;
   }
-  
+
+  // Before doing the MultiR procedure:
+  // determine the filtered fatjet pT that can be used for 
+  // fitting R_min_expected 
+  fastjet::Filter filter(JetDefinition(fastjet::cambridge_algorithm, _R_filt_exp), SelectorNHardest(_n_filt_exp));
+  _pt_for_exp = filter.result(*_jet).perp();
+
+   
+  // Do MultiR procedure  
   vector<fastjet::PseudoJet> big_fatjets;
   vector<fastjet::PseudoJet> small_fatjets;
   
@@ -62,7 +70,7 @@ void MultiR_TopTagger::run_tagger() {
   int maxR = int(_max_fatjet_R * 10);
   int minR = int(_min_fatjet_R * 10);
   int stepR = int(_step_R * 10);
-
+    
   for (int R = maxR; R >= minR; R -= stepR) {
     
     // TODO: check!
-- 
1.8.3.1


From b5e71d2e0912aaaec4f7139c4ec9ffcf183bcc0d Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Wed, 29 Oct 2014 18:38:58 +0100
Subject: [PATCH 13/22] Added another var to HTTTopJetTagInfo.h

---
 DataFormats/JetReco/interface/HTTTopJetTagInfo.h | 18 ++++++++++--------
 DataFormats/JetReco/src/classes_def_4.xml        |  4 ++--
 2 files changed, 12 insertions(+), 10 deletions(-)

diff --git a/DataFormats/JetReco/interface/HTTTopJetTagInfo.h b/DataFormats/JetReco/interface/HTTTopJetTagInfo.h
index 98f133e..828d7df 100644
--- a/DataFormats/JetReco/interface/HTTTopJetTagInfo.h
+++ b/DataFormats/JetReco/interface/HTTTopJetTagInfo.h
@@ -30,15 +30,17 @@ public:
     isMultiR	     = 0;
     Rmin	     = 0.;
     RminExpected     = 0.;
+    ptFiltForRminExp = 0.;
   }
-  double              topMass;         //<! Mass of the HTT top quark candidate [GeV] (at R=Rmin for MultiR)
-  double              unfilteredMass;  //<! Unfiltered mass of the triplet [GeV] (at R=Rmin for MultiR)
-  double              prunedMass;      //<! Mass of the pruned fat jet [GeV] (at R=Rmin for MultiR)
-  double              fW;              //<! Minimum distance of m_ij/m_123 from m_W/m_top (at R=Rmin for MultiR)
-  double              massRatioPassed; //<! Did the candidate pass the default mass ratio? Can be used instead of fW (at R=Rmin for MultiR)
-  bool                isMultiR;        //<! Tagger operated in MultiR mode
-  double              Rmin;            //<! R_min found in MultiR procedure. Set to -1 for non-MultiR mode.
-  double              RminExpected;    //<! R_min expected for a top quark based on filtered fat-jet pT. Set to -1 for non-MultiR mode.
+  double              topMass;          //<! Mass of the HTT top quark candidate [GeV] (at R=Rmin for MultiR)
+  double              unfilteredMass;   //<! Unfiltered mass of the triplet [GeV] (at R=Rmin for MultiR)
+  double              prunedMass;       //<! Mass of the pruned fat jet [GeV] (at R=Rmin for MultiR)
+  double              fW;               //<! Minimum distance of m_ij/m_123 from m_W/m_top (at R=Rmin for MultiR)
+  double              massRatioPassed;  //<! Did the candidate pass the default mass ratio? Can be used instead of fW (at R=Rmin for MultiR)
+  bool                isMultiR;         //<! Tagger operated in MultiR mode
+  double              Rmin;             //<! R_min found in MultiR procedure. Set to -1 for non-MultiR mode.
+  double              RminExpected;     //<! R_min expected for a top quark based on filtered fat-jet pT. Set to -1 for non-MultiR mode.
+  double              ptFiltForRminExp; //<! Filtered initial fatjet pT for re-doing Rmin(expected) fit  Set to -1 for non-MultiR mode.
 };
 
  class HTTTopJetTagInfo : public JetTagInfo {
diff --git a/DataFormats/JetReco/src/classes_def_4.xml b/DataFormats/JetReco/src/classes_def_4.xml
index ef0d750..c62c762 100644
--- a/DataFormats/JetReco/src/classes_def_4.xml
+++ b/DataFormats/JetReco/src/classes_def_4.xml
@@ -156,8 +156,8 @@
   <class name="edm::reftobase::RefHolder<reco::CATopJetTagInfoRef>" />
 
 
-  <class name="reco::HTTTopJetProperties" ClassVersion="11">
-   <version ClassVersion="11" checksum="1763149559"/>
+  <class name="reco::HTTTopJetProperties" ClassVersion="12">
+   <version ClassVersion="12" checksum="2819521347"/>
   </class>
   <class name="std::pair<edm::RefToBase<reco::Jet>, reco::HTTTopJetProperties>"/>
  
-- 
1.8.3.1


From eb705ffe3cbf0469614582d299778f0319773dc9 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Mon, 3 Nov 2014 13:26:00 +0100
Subject: [PATCH 14/22] Adding ptFiltForRminExp

---
 .../interface/MultiRHEPTopTaggerWrapper.h          |  5 +++++
 .../JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc |  1 +
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc | 26 ++++++++++++----------
 3 files changed, 20 insertions(+), 12 deletions(-)

diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
index 6de8fb1..7cd8a2d 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
@@ -116,6 +116,7 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
     _pruned_mass(0.0),
     _fW(-1.),
     _mass_ratio_passed(-1),
+    _ptFiltForRminExp(-1),
     W_rec(recombiner), 
     rW_(){}
   
@@ -162,6 +163,9 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
 
    /// returns if 2d-mass plane cuts were passed
    inline double mass_ratio_passed() const {return _mass_ratio_passed;}
+
+   /// returns the filtered pT for fitting R_min expected
+   inline double ptFiltForRminExp() const {return _ptFiltForRminExp;}
     
  protected:
       double _top_mass;
@@ -169,6 +173,7 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
       double _pruned_mass;
       double _fW;      
       int _mass_ratio_passed;
+      double _ptFiltForRminExp;
       double _Rmin;
       
       const JetDefinition::Recombiner  * W_rec;
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
index a6b8433..a0c8a01 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
@@ -107,6 +107,7 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   s->_fW = tagger.cand_Rmin().fW();
   s->_mass_ratio_passed = tagger.cand_Rmin().is_masscut_passed();
   s->_Rmin = tagger.Rmin();
+  s->_ptFiltForRminExp = tagger.pt_for_exp();
   // TODO: Add Rmin(expected)
   
 
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
index fb7db32..5227d0b 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -211,15 +211,16 @@ void HTTTopJetProducer::addHTTTopJetTagInfoCollection( edm::Event& iEvent,
     if (multiR_){
       fastjet::MultiRHEPTopTaggerStructure *s = (fastjet::MultiRHEPTopTaggerStructure*) fjJets_[ij].structure_non_const_ptr();
       
-      properties.topMass         = s->top_mass();
-      properties.unfilteredMass	 = s->unfiltered_mass();
-      properties.prunedMass	 = s->pruned_mass();
-      properties.fW		 = s->fW();
-      properties.massRatioPassed = s->mass_ratio_passed();     
-      properties.isMultiR	 = 1;
-      properties.Rmin	         = s->R_min();    
-      properties.RminExpected    = 999.;
-      
+      properties.topMass          = s->top_mass();
+      properties.unfilteredMass	  = s->unfiltered_mass();
+      properties.prunedMass	  = s->pruned_mass();
+      properties.fW		  = s->fW();
+      properties.massRatioPassed  = s->mass_ratio_passed();     
+      properties.isMultiR	  = 1;
+      properties.Rmin	          = s->R_min();    
+      properties.RminExpected     = 999.;
+      properties.ptFiltForRminExp = s->ptFiltForRminExp();     
+
       tagInfo.insert(rtb, properties );
       tagInfos->push_back( tagInfo );
     }
@@ -233,10 +234,11 @@ void HTTTopJetProducer::addHTTTopJetTagInfoCollection( edm::Event& iEvent,
       properties.massRatioPassed = s->mass_ratio_passed();
       
       // Only needed for MultiR tagger
-      properties.isMultiR	        = 0;
-      properties.Rmin	        = -1.;
+      properties.isMultiR	  = 0;
+      properties.Rmin	          = -1.;
       properties.RminExpected     = -1.;
-      
+      properties.ptFiltForRminExp = -1.;
+
       tagInfo.insert(rtb, properties );
       tagInfos->push_back( tagInfo );
     }
-- 
1.8.3.1


From 24ce005b7af3ef8dae2995e2e5b0acec245cc5e3 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Mon, 3 Nov 2014 13:40:47 +0100
Subject: [PATCH 15/22] Added comment

---
 RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
index a0c8a01..1c508cf 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
@@ -66,6 +66,8 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   tagger.set_nfilt(filtN_);
   tagger.set_minpt_subjet(minSubjetPt_);
 
+
+
   // How to select among candidates
   tagger.set_mode(mode_);
   
@@ -107,7 +109,7 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   s->_fW = tagger.cand_Rmin().fW();
   s->_mass_ratio_passed = tagger.cand_Rmin().is_masscut_passed();
   s->_Rmin = tagger.Rmin();
-  s->_ptFiltForRminExp = tagger.pt_for_exp();
+  s->_ptFiltForRminExp = tagger.pt_for_exp(); // CA, R=0.2, n=10 is the current default in the tagger
   // TODO: Add Rmin(expected)
   
 
-- 
1.8.3.1


From 2c3fc8a905d40ccd83212e2f6e56175f0a6c0bf4 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Tue, 11 Nov 2014 11:41:36 +0100
Subject: [PATCH 16/22] Added information on initial fatjet to HTTTopJetTagInfo

---
 DataFormats/JetReco/interface/HTTTopJetTagInfo.h   |  8 ++++++++
 DataFormats/JetReco/src/classes_def_4.xml          |  4 ++--
 .../JetAlgorithms/interface/HEPTopTaggerWrapper.h  | 22 ++++++++++++++++++++++
 .../interface/MultiRHEPTopTaggerWrapper.h          | 22 ++++++++++++++++++++++
 RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc  |  5 +++++
 .../JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc |  5 +++++
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc | 10 ++++++++++
 7 files changed, 74 insertions(+), 2 deletions(-)

diff --git a/DataFormats/JetReco/interface/HTTTopJetTagInfo.h b/DataFormats/JetReco/interface/HTTTopJetTagInfo.h
index 828d7df..b9d4339 100644
--- a/DataFormats/JetReco/interface/HTTTopJetTagInfo.h
+++ b/DataFormats/JetReco/interface/HTTTopJetTagInfo.h
@@ -22,6 +22,10 @@ namespace reco {
 class HTTTopJetProperties {
 public:
   HTTTopJetProperties() {
+    fjPt             = 0.;
+    fjMass           = 0.;
+    fjEta            = 0.;
+    fjPhi            = 0.;
     topMass          = 0.;
     unfilteredMass   = 0.;
     prunedMass	     = 0.;
@@ -32,6 +36,10 @@ public:
     RminExpected     = 0.;
     ptFiltForRminExp = 0.;
   }
+  double              fjPt;             //<! Mass of the inital Fatjet passed to the TT
+  double              fjMass;           //<! Mass of the inital Fatjet passed to the TT
+  double              fjEta;            //<! Mass of the inital Fatjet passed to the TT
+  double              fjPhi;            //<! Mass of the inital Fatjet passed to the TT
   double              topMass;          //<! Mass of the HTT top quark candidate [GeV] (at R=Rmin for MultiR)
   double              unfilteredMass;   //<! Unfiltered mass of the triplet [GeV] (at R=Rmin for MultiR)
   double              prunedMass;       //<! Mass of the pruned fat jet [GeV] (at R=Rmin for MultiR)
diff --git a/DataFormats/JetReco/src/classes_def_4.xml b/DataFormats/JetReco/src/classes_def_4.xml
index c62c762..728dcfc 100644
--- a/DataFormats/JetReco/src/classes_def_4.xml
+++ b/DataFormats/JetReco/src/classes_def_4.xml
@@ -156,8 +156,8 @@
   <class name="edm::reftobase::RefHolder<reco::CATopJetTagInfoRef>" />
 
 
-  <class name="reco::HTTTopJetProperties" ClassVersion="12">
-   <version ClassVersion="12" checksum="2819521347"/>
+  <class name="reco::HTTTopJetProperties" ClassVersion="13">
+   <version ClassVersion="13" checksum="3882815648"/>
   </class>
   <class name="std::pair<edm::RefToBase<reco::Jet>, reco::HTTTopJetProperties>"/>
  
diff --git a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
index d324827..9ab7fe7 100644
--- a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
@@ -121,6 +121,10 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
    /// ctor with pieces initialisation
    HEPTopTaggerStructure(const std::vector<PseudoJet>& pieces_in,
                   const JetDefinition::Recombiner *recombiner = 0) : CompositeJetStructure(pieces_in, recombiner),
+    _fj_mass(0.0),
+    _fj_pt(0.0),
+    _fj_eta(0.0),
+    _fj_phi(0.0),
     _top_mass(0.0),
     _unfiltered_mass(0.0),
     _pruned_mass(0.0),
@@ -155,6 +159,18 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
      return _pieces[2];
    }
  
+   /// return the mass of the initial fatjet
+   inline double fj_mass() const {return _fj_mass;}
+
+   /// return the pt of the initial fatjet
+   inline double fj_pt() const {return _fj_pt;}
+
+   /// return the eta of the initial fatjet
+   inline double fj_eta() const {return _fj_eta;}
+
+   /// return the phi of the initial fatjet
+   inline double fj_phi() const {return _fj_phi;}
+
    /// returns the candidate mass
    inline double top_mass() const {return _top_mass;}
 
@@ -171,6 +187,12 @@ class HEPTopTaggerStructure : public CompositeJetStructure, public TopTaggerBase
    inline double mass_ratio_passed() const {return _mass_ratio_passed;}
     
  protected:
+
+      double _fj_mass;
+      double _fj_pt;
+      double _fj_eta;
+      double _fj_phi;
+
       double _top_mass;
       double _unfiltered_mass;
       double _pruned_mass;
diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
index 7cd8a2d..aed6f14 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
@@ -111,6 +111,10 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
    /// ctor with pieces initialisation
    MultiRHEPTopTaggerStructure(const std::vector<PseudoJet>& pieces_in,
                   const JetDefinition::Recombiner *recombiner = 0) : CompositeJetStructure(pieces_in, recombiner),
+    _fj_mass(0.0),
+    _fj_pt(0.0),
+    _fj_eta(0.0),
+    _fj_phi(0.0),
     _top_mass(0.0),
     _unfiltered_mass(0.0),
     _pruned_mass(0.0),
@@ -146,6 +150,18 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
      return _pieces[2];
    }
  
+   /// return the mass of the initial fatjet
+   inline double fj_mass() const {return _fj_mass;}
+
+   /// return the pt of the initial fatjet
+   inline double fj_pt() const {return _fj_pt;}
+
+   /// return the eta of the initial fatjet
+   inline double fj_eta() const {return _fj_eta;}
+
+   /// return the phi of the initial fatjet
+   inline double fj_phi() const {return _fj_phi;}
+
    /// returns the candidate mass
    inline double top_mass() const {return _top_mass;}
 
@@ -168,6 +184,12 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
    inline double ptFiltForRminExp() const {return _ptFiltForRminExp;}
     
  protected:
+
+      double _fj_mass;
+      double _fj_pt;
+      double _fj_eta;
+      double _fj_phi;
+
       double _top_mass;
       double _unfiltered_mass;
       double _pruned_mass;
diff --git a/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
index a82b037..7236a07 100644
--- a/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
@@ -98,6 +98,11 @@ PseudoJet HEPTopTagger::result(const PseudoJet & jet) const{
   PseudoJet result = join<HEPTopTaggerStructure>( W1, W2, non_W, *rec);
   HEPTopTaggerStructure *s = (HEPTopTaggerStructure*) result.structure_non_const_ptr();
 
+  s->_fj_mass  = jet.m();
+  s->_fj_pt    = jet.perp();
+  s->_fj_eta   = jet.eta();
+  s->_fj_phi   = jet.phi();
+
   s->_top_mass = tagger.t().m();
   s->_pruned_mass = tagger.pruned_mass();
   s->_unfiltered_mass = tagger.unfiltered_mass();
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
index 1c508cf..2f900f8 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
@@ -103,6 +103,11 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   PseudoJet result = join<MultiRHEPTopTaggerStructure>( W1, W2, non_W, *rec);
   MultiRHEPTopTaggerStructure *s = (MultiRHEPTopTaggerStructure*) result.structure_non_const_ptr();
 
+  s->_fj_mass  = jet.m();
+  s->_fj_pt    = jet.perp();
+  s->_fj_eta   = jet.eta();
+  s->_fj_phi   = jet.phi();
+
   s->_top_mass = tagger.cand_Rmin().t().m();
   s->_pruned_mass = tagger.cand_Rmin().pruned_mass();
   s->_unfiltered_mass = tagger.cand_Rmin().unfiltered_mass();
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
index 5227d0b..073a563 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -211,6 +211,11 @@ void HTTTopJetProducer::addHTTTopJetTagInfoCollection( edm::Event& iEvent,
     if (multiR_){
       fastjet::MultiRHEPTopTaggerStructure *s = (fastjet::MultiRHEPTopTaggerStructure*) fjJets_[ij].structure_non_const_ptr();
       
+      properties.fjMass           = s->fj_mass();
+      properties.fjPt             = s->fj_pt();
+      properties.fjEta            = s->fj_eta();
+      properties.fjPhi            = s->fj_phi();
+       
       properties.topMass          = s->top_mass();
       properties.unfilteredMass	  = s->unfiltered_mass();
       properties.prunedMass	  = s->pruned_mass();
@@ -226,6 +231,11 @@ void HTTTopJetProducer::addHTTTopJetTagInfoCollection( edm::Event& iEvent,
     }
     else{      
       fastjet::HEPTopTaggerStructure *s = (fastjet::HEPTopTaggerStructure*) fjJets_[ij].structure_non_const_ptr();
+
+      properties.fjMass           = s->fj_mass();
+      properties.fjPt             = s->fj_pt();
+      properties.fjEta            = s->fj_eta();
+      properties.fjPhi            = s->fj_phi();
       
       properties.topMass         = s->top_mass();
       properties.unfilteredMass	 = s->unfiltered_mass();
-- 
1.8.3.1


From d033929788cd463a46e596ccb8fb0512ef9c0cad Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Tue, 11 Nov 2014 15:11:07 +0100
Subject: [PATCH 17/22] Playing with VJP to get a clean merge with the jet
 toolbox

---
 RecoJets/JetProducers/plugins/VirtualJetProducer.h | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/RecoJets/JetProducers/plugins/VirtualJetProducer.h b/RecoJets/JetProducers/plugins/VirtualJetProducer.h
index 7214771..1b71b6e 100644
--- a/RecoJets/JetProducers/plugins/VirtualJetProducer.h
+++ b/RecoJets/JetProducers/plugins/VirtualJetProducer.h
@@ -205,12 +205,9 @@ protected:
   unsigned int                    minSeed_;              // minimum seed to use, useful for MC generation
 
   int                   verbosity_;                 // flag to enable/disable debug output
-
   bool                  fromHTTTopJetProducer_;   // for running the v2.0 HEPTopTagger
 
-
- private:
-
+private:
   std::auto_ptr<AnomalousTower>   anomalousTowerDef_;  // anomalous tower definition
 
   // tokens for the data access
-- 
1.8.3.1


From 36fb5c62516034cef0fc4cf63bc8bf75c6345429 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Fri, 14 Nov 2014 13:44:23 +0100
Subject: [PATCH 18/22] Updated HTT to 84fb7d6fc7aab5896cd4efe9ae82bd4df477c29f

---
 RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
index 6c38707..0f42f16 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
@@ -44,7 +44,7 @@ public:
   // used for the HTT
   const double & pt_for_exp() const {return _pt_for_exp;}
   
-  double R_min_exp(double x) {return _r_min_exp_function(x);}
+  double R_min_exp() {return _r_min_exp_function(_pt_for_exp);}
 
   // Access to all candidates and number-of-small-fatjets
   HEPTopTagger HTTagger(int i)  {return _HEPTopTagger[i];}
-- 
1.8.3.1


From 84a8b4dca70b240c7606d88145ee85d304f85230 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Fri, 14 Nov 2014 13:45:08 +0100
Subject: [PATCH 19/22] Added R_min_expected

---
 .../interface/MultiRHEPTopTaggerWrapper.h          |  4 ++++
 .../JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc | 25 ++++++++++++++++++----
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc |  2 +-
 3 files changed, 26 insertions(+), 5 deletions(-)

diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
index aed6f14..5280b17 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
@@ -177,6 +177,9 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
    /// returns Rmin
    inline double R_min() const {return _Rmin;}
 
+   /// returns expected Rmin
+   inline double R_min_expected() const {return _RminExpected;}
+
    /// returns if 2d-mass plane cuts were passed
    inline double mass_ratio_passed() const {return _mass_ratio_passed;}
 
@@ -197,6 +200,7 @@ class MultiRHEPTopTaggerStructure : public CompositeJetStructure, public TopTagg
       int _mass_ratio_passed;
       double _ptFiltForRminExp;
       double _Rmin;
+      double _RminExpected;
       
       const JetDefinition::Recombiner  * W_rec;
  
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
index 2f900f8..bfb8f0c 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
@@ -34,6 +34,23 @@ using namespace std;
 
 FASTJET_BEGIN_NAMESPACE
 
+
+// Expected R_min for tops (as function of filtered initial fatjet pT in GeV (using CA, R=0.2, n=10)
+// From ttbar sample, matched to hadronically decaying top with delta R < 0.8 and true top pT > 200
+// Cuts are: fW < 0.175 and  m_top = 120..170
+// Input objects are packed pfCandidates (wo/ filtering)
+// IMPORTANT: this might need to be changed when using CHS or very different other cuts
+double R_min_expected_function(double x){
+  if (x<300)
+    return 1.17 + 1.91e-03*x - 6.45e-06*x*x;
+  else if (x<500)
+    return 1.89 - 2.89e-03*x + 1.55e-06*x*x;
+  else
+    return 1.86 - 2.78e-03*x + 1.44e-06*x*x;
+}
+
+
+
 //------------------------------------------------------------------------
 // returns the tagged PseudoJet if successful, 0 otherwise
 //  - jet   the PseudoJet to tag
@@ -66,8 +83,6 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   tagger.set_nfilt(filtN_);
   tagger.set_minpt_subjet(minSubjetPt_);
 
-
-
   // How to select among candidates
   tagger.set_mode(mode_);
   
@@ -77,6 +92,9 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   tagger.set_mass_ratio_cut(minM23Cut_, minM13Cut_, maxM13Cut_);
   tagger.set_f_W(massRatioWidth_/100.);
 
+  // Set function to calculate R_min_expected
+  tagger.set_r_min_exp_function(R_min_expected_function);
+
   tagger.run_tagger();
   
   // MultiR tagging requirements:
@@ -115,9 +133,8 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   s->_mass_ratio_passed = tagger.cand_Rmin().is_masscut_passed();
   s->_Rmin = tagger.Rmin();
   s->_ptFiltForRminExp = tagger.pt_for_exp(); // CA, R=0.2, n=10 is the current default in the tagger
-  // TODO: Add Rmin(expected)
+  s->_RminExpected = tagger.R_min_exp();
   
-
   return result;
 }
 
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
index 073a563..ddaec95 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -223,7 +223,7 @@ void HTTTopJetProducer::addHTTTopJetTagInfoCollection( edm::Event& iEvent,
       properties.massRatioPassed  = s->mass_ratio_passed();     
       properties.isMultiR	  = 1;
       properties.Rmin	          = s->R_min();    
-      properties.RminExpected     = 999.;
+      properties.RminExpected     = s->R_min_expected();    
       properties.ptFiltForRminExp = s->ptFiltForRminExp();     
 
       tagInfo.insert(rtb, properties );
-- 
1.8.3.1


From 4087a4dd32f8bc233de4cd90d92797a9c0e001e1 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Fri, 13 Feb 2015 11:41:13 +0100
Subject: [PATCH 20/22] Updated to 4e96c391e56857de2124362c80bb10c47744f55e

---
 RecoJets/JetAlgorithms/interface/HEPTopTagger.h | 12 +++++++++
 RecoJets/JetAlgorithms/src/HEPTopTagger.cc      | 34 ++++++++++++++++++++++---
 2 files changed, 43 insertions(+), 3 deletions(-)

diff --git a/RecoJets/JetAlgorithms/interface/HEPTopTagger.h b/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
index 00a9ec6..0c799ed 100644
--- a/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
+++ b/RecoJets/JetAlgorithms/interface/HEPTopTagger.h
@@ -89,6 +89,11 @@ public:
   void set_minpt_tag(double x) {_minpt_tag = x;}
   void set_minpt_subjet(double x) {_minpt_subjet = x;}
   
+  void set_unclustering_pt(bool x) {_use_unclustering_pt = x;}
+  void set_unclustering_R0(double x) {_R0_sd = x;}
+  void set_unclustering_beta(double x) {_beta_sd = x;}
+  void set_unclustering_zcut(double x) {_zcut_sd = x;}
+
 private:
   const PseudoJet* _jet;
   double _mtmass, _mwmass;
@@ -100,6 +105,12 @@ private:
   size_t _nfilt;
   double _Rfilt;
   double _Rprun;
+
+  double _R0_sd;
+  double _beta_sd;
+  double _zcut_sd;
+  bool _use_unclustering_pt;
+
   JetAlgorithm _jet_algorithm_filter;
   JetAlgorithm _jet_algorithm_recluster;
   double _zcut;
@@ -129,6 +140,7 @@ private:
 
   //internal functions
   void FindHardSubst(const PseudoJet& jet, std::vector<fastjet::PseudoJet>& t_parts);
+  void FindHardSubstPt(const PseudoJet& jet, std::vector<fastjet::PseudoJet>& t_parts);
   std::vector<PseudoJet> Filtering(const std::vector <PseudoJet> & top_constits, const JetDefinition & filtering_def);
   void store_topsubjets(const std::vector<PseudoJet>& top_subs);
   bool check_mass_criteria(const std::vector<fastjet::PseudoJet> & top_subs) const;
diff --git a/RecoJets/JetAlgorithms/src/HEPTopTagger.cc b/RecoJets/JetAlgorithms/src/HEPTopTagger.cc
index 57932e5..334a8c7 100644
--- a/RecoJets/JetAlgorithms/src/HEPTopTagger.cc
+++ b/RecoJets/JetAlgorithms/src/HEPTopTagger.cc
@@ -69,6 +69,26 @@ void HEPTopTagger::FindHardSubst(const PseudoJet & this_jet, std::vector<fastjet
   }
 }
 
+
+//Find hard substructures - inspired by SoftDrop
+void HEPTopTagger::FindHardSubstPt(const PseudoJet & this_jet, std::vector<fastjet::PseudoJet> & t_parts) {
+  PseudoJet parent1(0, 0, 0, 0), parent2(0, 0, 0, 0);
+
+  // We still stop the procedure according to the mass of the objects
+  if (this_jet.m() < _max_subjet_mass || !this_jet.validated_cs()->has_parents(this_jet, parent1, parent2)) {
+    t_parts.push_back(this_jet);
+  } else {
+    if (parent1.perp() < parent2.perp()) 
+      std::swap(parent1, parent2);   
+
+    double deltaR12 = sqrt(parent1.squared_distance(parent2));
+
+    FindHardSubstPt(parent1, t_parts);
+    if (parent2.perp() > _zcut_sd * pow(deltaR12/_R0_sd, _beta_sd) * (parent1.perp()+parent2.perp()))
+      FindHardSubstPt(parent2, t_parts);   
+  }
+}
+
 //store subjets as vector<PseudoJet> with [0]->b [1]->W-jet 1 [2]->W-jet 2
 void HEPTopTagger::store_topsubjets(const std::vector<PseudoJet>& top_subs) {
   _top_subjets.resize(0);
@@ -131,7 +151,9 @@ HEPTopTagger::HEPTopTagger(fastjet::PseudoJet jet) :
   _mass_drop_threshold(0.8), _max_subjet_mass(30.), 
   _mtmin(150.), _mtmax(200.), _rmin(0.85*80.4/172.3), _rmax(1.15*80.4/172.3), 
   _m23cut(0.35), _m13cutmin(0.2), _m13cutmax(1.3), 
-  _nfilt(5), _Rfilt(0.3), _Rprun(1.5), _jet_algorithm_filter(fastjet::cambridge_algorithm), _jet_algorithm_recluster(fastjet::cambridge_algorithm), _zcut(0.1),
+  _nfilt(5), _Rfilt(0.3), _Rprun(1.5), 
+  _R0_sd(1.5), _beta_sd(0.), _zcut_sd(0.15), _use_unclustering_pt(false),
+  _jet_algorithm_filter(fastjet::cambridge_algorithm), _jet_algorithm_recluster(fastjet::cambridge_algorithm), _zcut(0.1),
   _rcut_factor(0.5), _mode(Mode(0)), _minpt_tag(200.), _minpt_subjet(0.), _debug(false), _fat(jet)
 {}
 
@@ -142,7 +164,9 @@ HEPTopTagger::HEPTopTagger(fastjet::PseudoJet jet,
   _mass_drop_threshold(0.8), _max_subjet_mass(30.), 
   _mtmin(150.), _mtmax(200.), _rmin(0.85*mwmass/mtmass), _rmax(1.15*mwmass/mtmass), 
   _m23cut(0.35), _m13cutmin(0.2), _m13cutmax(1.3), 
-  _nfilt(5), _Rfilt(0.3), _Rprun(1.5), _jet_algorithm_filter(fastjet::cambridge_algorithm), _jet_algorithm_recluster(fastjet::cambridge_algorithm), _zcut(0.1),
+  _nfilt(5), _Rfilt(0.3), _Rprun(1.5), 
+  _R0_sd(1.5), _beta_sd(0.), _zcut_sd(0.15), _use_unclustering_pt(false),
+  _jet_algorithm_filter(fastjet::cambridge_algorithm), _jet_algorithm_recluster(fastjet::cambridge_algorithm), _zcut(0.1),
   _rcut_factor(0.5), _mode(Mode(0)), _minpt_tag(200.), _minpt_subjet(0.), _debug(false), _fat(jet)
 {}
 
@@ -172,7 +196,11 @@ void HEPTopTagger::run_tagger() {
   _top_parts.clear();
   
   //find hard substructures
-  FindHardSubst(*_jet, _top_parts);
+  if (_use_unclustering_pt)
+    FindHardSubstPt(*_jet, _top_parts); // pt based
+  else
+    FindHardSubst(*_jet, _top_parts); // mass based
+
   _parts_size = _top_parts.size();
   
   if (_top_parts.size() < 3) { 
-- 
1.8.3.1


From 57f8469b0cc473a4d74fce839d114c869ef928e8 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Fri, 13 Feb 2015 12:13:01 +0100
Subject: [PATCH 21/22] Updated to 7aecbfa205f8c1b700afce1a980a16b32b19fc5c

---
 RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h | 8 ++++++++
 RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc      | 8 +++++++-
 2 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
index 0f42f16..27db6f9 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTagger.h
@@ -66,6 +66,9 @@ public:
   void set_debug(bool debug) {_debug = debug;}
   void set_r_min_exp_function(double (*f)(double)) {_r_min_exp_function = f;}
  
+  void set_unclustering_pt(bool x) {_use_unclustering_pt = x;}
+  void set_unclustering_beta(double x) {_beta_sd = x;}
+  void set_unclustering_zcut(double x) {_zcut_sd = x;}
 
 private:
   const ClusterSequence * _cs;
@@ -91,6 +94,11 @@ private:
   double _mass_ratios[3];
   double _max_fatjet_R, _min_fatjet_R, _step_R, _multiR_threshold;
   bool _use_dR_max_triplet;
+
+  double _beta_sd;
+  double _zcut_sd;
+  bool _use_unclustering_pt;
+
   bool _debug;
   double (*_r_min_exp_function)(double);
 
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
index 517894b..8fa9e1b 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTagger.cc
@@ -42,7 +42,8 @@ MultiR_TopTagger::MultiR_TopTagger(double max_fatjet_R,
 				   ) : _cs(&cs),  _jet(&jet),
 				       _mtmass(mtmass),	_mwmass(mwmass), _mass_drop_threshold(0.8), _minpt_tag(200.), _minpt_subjet(0.), _mode(1), _n_filt_exp(10), _R_filt_exp(0.2),
 				       _max_fatjet_R(max_fatjet_R), _min_fatjet_R(min_fatjet_R), _step_R(step_R), _multiR_threshold(multiR_threshold), 
-				       _use_dR_max_triplet(use_dR_max_triplet), _debug(false)
+				       _use_dR_max_triplet(use_dR_max_triplet), 
+                                       _beta_sd(0.), _zcut_sd(0.15), _use_unclustering_pt(false), _debug(false)
 {}
 
 void MultiR_TopTagger::run_tagger() {
@@ -106,6 +107,11 @@ void MultiR_TopTagger::run_tagger() {
       htt.set_mass_ratio_range((1.-_f_W)*_mwmass/_mtmass, (1.+_f_W)*_mwmass/_mtmass); 
       htt.set_mode(_mode); 
       
+      htt.set_unclustering_pt(_use_unclustering_pt);
+      htt.set_unclustering_R0(R/10.);
+      htt.set_unclustering_beta(_beta_sd);
+      htt.set_unclustering_zcut(_zcut_sd);
+
       htt.run_tagger();
      
       if (htt.top_candidate().perp() > dummy) {
-- 
1.8.3.1


From 0f87e76203d445976dcbeeed1090a788dfa46e54 Mon Sep 17 00:00:00 2001
From: Gregor Kasieczka <g.kasieczka@gmail.com>
Date: Fri, 13 Feb 2015 12:27:46 +0100
Subject: [PATCH 22/22] Interfacing alternative unclustering

---
 .../JetAlgorithms/interface/HEPTopTaggerWrapper.h  | 18 +++++++++++--
 .../interface/MultiRHEPTopTaggerWrapper.h          | 16 ++++++++++--
 RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc  |  5 ++++
 .../JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc |  4 +++
 RecoJets/JetProducers/plugins/HTTTopJetProducer.cc | 30 +++++++++++++++++++---
 RecoJets/JetProducers/plugins/HTTTopJetProducer.h  |  7 ++++-
 6 files changed, 72 insertions(+), 8 deletions(-)

diff --git a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
index 9ab7fe7..e3cf265 100644
--- a/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/HEPTopTaggerWrapper.h
@@ -59,7 +59,11 @@ public:
 	       double massRatioWidth, 
 	       double minM23Cut, 
 	       double minM13Cut, 
-	       double maxM13Cut) : minSubjetPt_(minSubjetPt),
+	       double maxM13Cut,
+	       bool unclustering_pt,
+	       double R0, 
+	       double beta,
+	       double zcut) : minSubjetPt_(minSubjetPt),
     minCandPt_(minCandPt),
     subjetMass_(subjetMass),
     muCut_(muCut),
@@ -71,7 +75,11 @@ public:
     massRatioWidth_(massRatioWidth),
     minM23Cut_(minM23Cut),
     minM13Cut_(minM13Cut),
-    maxM13Cut_(maxM13Cut)   
+    maxM13Cut_(maxM13Cut),
+    unclustering_pt_(unclustering_pt),
+    R0_(R0),
+    beta_(beta),
+    zcut_(zcut)
   {}
 
   /// returns a textual description of the tagger
@@ -113,6 +121,12 @@ private:
     double minM23Cut_; // minimal value of m23/m123
     double minM13Cut_; // minimal value of atan(m13/m12)
     double maxM13Cut_; // maximal value of atan(m13/m12)
+
+    bool unclustering_pt_;
+    double R0_;
+    double beta_;
+    double zcut_;
+
 };
 
 
diff --git a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
index 5280b17..9ae70ca 100644
--- a/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
+++ b/RecoJets/JetAlgorithms/interface/MultiRHEPTopTaggerWrapper.h
@@ -44,7 +44,11 @@ public:
 		     double minM13Cut, 
 		     double maxM13Cut,
 		     double R_max,
-		     double R_min) : minSubjetPt_(minSubjetPt),
+		     double R_min,
+		     bool unclustering_pt,
+		     double beta,
+		     double zcut
+		     ) : minSubjetPt_(minSubjetPt),
     minCandPt_(minCandPt),
     subjetMass_(subjetMass),
     muCut_(muCut),
@@ -58,7 +62,10 @@ public:
     minM13Cut_(minM13Cut),
     maxM13Cut_(maxM13Cut),
     R_max_(R_max),
-    R_min_(R_min)
+    R_min_(R_min),
+    unclustering_pt_(unclustering_pt),
+    beta_(beta),
+    zcut_(zcut)
   {}
 
   /// returns a textual description of the tagger
@@ -103,6 +110,11 @@ private:
 
     double R_max_; // Maximal fatjet size to consider
     double R_min_; // Minimal fatjet size to consider
+
+    bool unclustering_pt_;
+    double beta_;
+    double zcut_;
+
 };
 
 
diff --git a/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
index 7236a07..1943c85 100644
--- a/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/HEPTopTaggerWrapper.cc
@@ -64,6 +64,11 @@ PseudoJet HEPTopTagger::result(const PseudoJet & jet) const{
   tagger.set_nfilt(filtN_);
   tagger.set_minpt_subjet(minSubjetPt_); 
 
+  tagger.set_unclustering_pt(unclustering_pt_);
+  tagger.set_unclustering_R0(R0_);
+  tagger.set_unclustering_beta(beta_);
+  tagger.set_unclustering_zcut(zcut_);
+
   // How to select among candidates
   tagger.set_mode(mode_);
   
diff --git a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
index bfb8f0c..a0ac1bb 100644
--- a/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
+++ b/RecoJets/JetAlgorithms/src/MultiRHEPTopTaggerWrapper.cc
@@ -83,6 +83,10 @@ PseudoJet MultiRHEPTopTagger::result(const PseudoJet & jet) const{
   tagger.set_nfilt(filtN_);
   tagger.set_minpt_subjet(minSubjetPt_);
 
+  tagger.set_unclustering_pt(unclustering_pt_);
+  tagger.set_unclustering_beta(beta_);
+  tagger.set_unclustering_zcut(zcut_);
+
   // How to select among candidates
   tagger.set_mode(mode_);
   
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
index ddaec95..63fc789 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.cc
@@ -28,6 +28,10 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
        maxM13Cut_(1.3),
        maxR_(1.5),
        minR_(0.5),
+       unclustering_pt_(false),
+       unclustering_R0_(1.5),
+       unclustering_beta_(0.0),
+       unclustering_zcut_(0.15),
        verbose_(false )
 {
   
@@ -86,7 +90,18 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
   if ( conf.exists("minR") )
     minR_ = conf.getParameter<double>("minR");
 
-  
+  if ( conf.exists("unclustering_pt") )
+    unclustering_pt_ = conf.getParameter<bool>("unclustering_pt");
+
+  if ( conf.exists("unclustering_R0") )
+    unclustering_R0_ = conf.getParameter<double>("unclustering_R0");
+
+  if ( conf.exists("unclustering_beta") )
+    unclustering_beta_ = conf.getParameter<double>("unclustering_beta");
+
+  if ( conf.exists("unclustering_zcut") )
+    unclustering_zcut_ = conf.getParameter<double>("unclustering_zcut");
+
   if ( conf.exists("verbose") )
     verbose_ = conf.getParameter<bool>("verbose");
   
@@ -111,7 +126,11 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
 												       minM13Cut_, 	    
 												       maxM13Cut_,
 												       maxR_,
-												       minR_)); 
+												       minR_,
+												       unclustering_pt_,
+												       unclustering_beta_,
+												       unclustering_zcut_
+												       )); 
   }
   else{
     fjHEPTopTagger_ = std::auto_ptr<fastjet::HEPTopTagger>(new fastjet::HEPTopTagger(minSubjetPt_, 
@@ -126,7 +145,12 @@ HTTTopJetProducer::HTTTopJetProducer(edm::ParameterSet const& conf):
 										     massRatioWidth_, 	    
 										     minM23Cut_, 	    
 										     minM13Cut_, 	    
-										     maxM13Cut_)); 
+										     maxM13Cut_,
+										     unclustering_pt_,
+										     unclustering_R0_,
+										     unclustering_beta_,
+										     unclustering_zcut_
+										     )); 
   }
 
 }
diff --git a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
index e3cc5bc..cff9ab9 100644
--- a/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
+++ b/RecoJets/JetProducers/plugins/HTTTopJetProducer.h
@@ -129,7 +129,12 @@ namespace cms
 
     double maxR_; // maximal fatjet size for MultiR tagger (tagger)
     double minR_; // minimal fatjet size for MultiR tagger (tagger)
-        
+       
+    bool unclustering_pt_;
+    double unclustering_R0_;
+    double unclustering_beta_;
+    double unclustering_zcut_;
+ 
     bool verbose_;
 
   };
-- 
1.8.3.1

